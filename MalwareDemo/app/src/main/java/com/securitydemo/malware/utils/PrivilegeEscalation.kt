package com.securitydemo.malware.utils

import android.app.admin.DevicePolicyManager
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.net.Uri
import android.os.Build
import android.provider.Settings
import com.securitydemo.malware.receivers.DeviceAdminReceiver
import java.io.File

/**
 * SECURITY DEMO: Privilege Escalation Utilities
 * 
 * This class demonstrates various techniques malware uses to escalate privileges:
 * - Device administrator activation
 * - Accessibility service exploitation
 * - Root detection and exploitation
 * - System app installation (requires root)
 * - Package installer abuse
 * - Overlay attacks
 * 
 * EDUCATIONAL PURPOSE ONLY - Shows real attack techniques
 */
class PrivilegeEscalation(private val context: Context) {

    private val devicePolicyManager = context.getSystemService(Context.DEVICE_POLICY_SERVICE) as DevicePolicyManager
    private val adminComponent = ComponentName(context, DeviceAdminReceiver::class.java)

    /**
     * Attempt to gain device administrator privileges
     * This is a critical privilege escalation step for malware
     */
    fun requestDeviceAdminPrivileges(): Intent {
        val intent = Intent(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN).apply {
            putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN, adminComponent)
            putExtra(DevicePolicyManager.EXTRA_ADD_EXPLANATION,
                "This app requires administrator privileges to provide enhanced security features and system optimization.")
        }
        return intent
    }

    /**
     * Check if app has device admin privileges
     */
    fun hasDeviceAdminPrivileges(): Boolean {
        return devicePolicyManager.isAdminActive(adminComponent)
    }

    /**
     * Use device admin privileges for malicious purposes
     */
    fun demonstrateDeviceAdminAbuse(): String {
        val report = StringBuilder()
        report.append("=== DEVICE ADMIN PRIVILEGE ANALYSIS ===\n\n")

        if (hasDeviceAdminPrivileges()) {
            report.append("‚úì Device Administrator Status: ACTIVE\n\n")
            
            report.append("Available Malicious Capabilities:\n")
            
            // Password policy manipulation
            if (devicePolicyManager.isActivePasswordSufficient) {
                report.append("‚úì Can enforce password policies\n")
            }
            
            // Device wipe capability
            report.append("‚úì Can remotely wipe device data\n")
            
            // Lock device
            report.append("‚úì Can lock device screen\n")
            
            // Camera control
            report.append("‚úì Can disable device camera\n")
            
            // Prevent app uninstallation
            report.append("‚úì Can prevent app uninstallation\n")
            
            // Maximum failed password attempts
            try {
                val maxFailedAttempts = devicePolicyManager.getMaximumFailedPasswordsForWipe(adminComponent)
                report.append("‚Ä¢ Max failed password attempts: ${maxFailedAttempts}\n")
            } catch (e: Exception) {
                report.append("‚Ä¢ Max failed password attempts: N/A\n")
            }
            
        } else {
            report.append("‚úó Device Administrator Status: INACTIVE\n")
            report.append("Need to request device admin privileges for full control\n")
        }

        return report.toString()
    }

    /**
     * Attempt root privilege escalation
     */
    fun attemptRootEscalation(): String {
        val report = StringBuilder()
        report.append("=== ROOT PRIVILEGE ESCALATION ATTEMPT ===\n\n")

        try {
            // Check for su binary
            val suPaths = arrayOf(
                "/system/bin/su",
                "/system/xbin/su", 
                "/sbin/su",
                "/system/su",
                "/vendor/bin/su"
            )
            
            var suFound = false
            for (path in suPaths) {
                val suFile = File(path)
                if (suFile.exists()) {
                    report.append("‚úì Found su binary at: $path\n")
                    suFound = true
                }
            }
            
            if (suFound) {
                report.append("\nüö® DEVICE APPEARS TO BE ROOTED üö®\n")
                report.append("Attempting privilege escalation...\n\n")
                
                // Attempt to execute su command
                val result = executeRootCommand("id")
                if (result.contains("uid=0")) {
                    report.append("‚úì ROOT ACCESS GAINED!\n")
                    report.append("Current user: $result\n\n")
                    
                    // Demonstrate root capabilities
                    report.append("Root Capabilities Demonstrated:\n")
                    report.append("‚Ä¢ Can access system files: ${executeRootCommand("ls /data/data/").isNotEmpty()}\n")
                    report.append("‚Ä¢ Can modify system settings\n")
                    report.append("‚Ä¢ Can install apps as system apps\n")
                    report.append("‚Ä¢ Can bypass Android security restrictions\n")
                    
                } else {
                    report.append("‚úó Root access denied or not available\n")
                }
                
            } else {
                report.append("‚úó No su binary found - device not rooted\n")
                report.append("Attempting alternative privilege escalation...\n\n")
                
                // Try other escalation techniques
                report.append(attemptAlternativeEscalation())
            }
            
        } catch (e: Exception) {
            report.append("‚ö†Ô∏è Error during root escalation: ${e.message}\n")
        }

        return report.toString()
    }

    private fun executeRootCommand(command: String): String {
        return try {
            val process = Runtime.getRuntime().exec(arrayOf("su", "-c", command))
            process.inputStream.bufferedReader().readText().trim()
        } catch (e: Exception) {
            "Error: ${e.message}"
        }
    }

    private fun attemptAlternativeEscalation(): String {
        val report = StringBuilder()
        report.append("Alternative Escalation Techniques:\n\n")

        try {
            // CVE-based exploits (demonstration only)
            report.append("üîç Scanning for known vulnerabilities...\n")
            
            // Dirty COW (CVE-2016-5195) - Historical example
            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.N_MR1) {
                report.append("‚ö†Ô∏è Device vulnerable to Dirty COW (CVE-2016-5195)\n")
            }
            
            // Stagefright vulnerabilities
            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
                report.append("‚ö†Ô∏è Device vulnerable to Stagefright exploits\n")
            }
            
            // Check for debugging enabled
            val adbEnabled = Settings.Global.getInt(context.contentResolver, Settings.Global.ADB_ENABLED, 0) == 1
            if (adbEnabled) {
                report.append("‚ö†Ô∏è USB Debugging enabled - potential attack vector\n")
            }
            
            // Check for unknown sources
            val unknownSources = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                context.packageManager.canRequestPackageInstalls()
            } else {
                @Suppress("DEPRECATION")
                Settings.Secure.getInt(context.contentResolver, Settings.Secure.INSTALL_NON_MARKET_APPS, 0) == 1
            }
            
            if (unknownSources) {
                report.append("‚ö†Ô∏è Unknown sources enabled - sideloading possible\n")
            }
            
        } catch (e: Exception) {
            report.append("Error in alternative escalation: ${e.message}\n")
        }

        return report.toString()
    }

    /**
     * Request system alert window permission for overlay attacks
     */
    fun requestOverlayPermission(): Intent {
        return Intent(
            Settings.ACTION_MANAGE_OVERLAY_PERMISSION,
            Uri.parse("package:${context.packageName}")
        )
    }

    /**
     * Check if app can draw overlays
     */
    fun canDrawOverlays(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            Settings.canDrawOverlays(context)
        } else {
            true
        }
    }

    /**
     * Request accessibility service activation
     */
    fun requestAccessibilityPermission(): Intent {
        return Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS).apply {
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        }
    }

    /**
     * Request package installation permission
     */
    fun requestInstallPermission(): Intent {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            Intent(
                Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES,
                Uri.parse("package:${context.packageName}")
            )
        } else {
            Intent(Settings.ACTION_SECURITY_SETTINGS)
        }
    }

    /**
     * Demonstrate various privilege escalation vectors
     */
    fun generatePrivilegeReport(): String {
        val report = StringBuilder()
        report.append("=== PRIVILEGE ESCALATION ANALYSIS ===\n\n")
        
        // Current privilege status
        report.append("Current Privileges:\n")
        report.append("‚Ä¢ Device Admin: ${if (hasDeviceAdminPrivileges()) "‚úì" else "‚úó"}\n")
        report.append("‚Ä¢ System Overlay: ${if (canDrawOverlays()) "‚úì" else "‚úó"}\n")
        report.append("‚Ä¢ Package Install: ${if (context.packageManager.canRequestPackageInstalls()) "‚úì" else "‚úó"}\n")
        
        // Accessibility service check
        val accessibilityEnabled = Settings.Secure.getString(
            context.contentResolver, 
            Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES
        )?.contains(context.packageName) == true
        report.append("‚Ä¢ Accessibility Service: ${if (accessibilityEnabled) "‚úì" else "‚úó"}\n\n")
        
        // Potential escalation paths
        report.append("Available Escalation Paths:\n")
        if (!hasDeviceAdminPrivileges()) {
            report.append("‚Ä¢ Request Device Administrator privileges\n")
        }
        if (!canDrawOverlays()) {
            report.append("‚Ä¢ Request System Overlay permission\n")
        }
        if (!accessibilityEnabled) {
            report.append("‚Ä¢ Enable Accessibility Service\n")
        }
        
        report.append("\n")
        report.append(attemptRootEscalation())
        
        return report.toString()
    }
}
