package com.securitydemo.malware.activities

import android.Manifest
import android.app.AlertDialog
import android.content.pm.PackageManager
import android.os.Bundle
import android.widget.Button
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import com.securitydemo.malware.R
import com.securitydemo.malware.services.DataExfiltrationService
import com.securitydemo.malware.utils.DataCollector
import kotlinx.coroutines.*

/**
 * SECURITY DEMO: Data Exfiltration Activity
 * 
 * This activity demonstrates how malware steals sensitive user data:
 * - Contacts and phone numbers
 * - SMS messages and call logs
 * - Location data and movement patterns
 * - Photos and media files
 * - App usage statistics
 * - Device and account information
 * 
 * EDUCATIONAL PURPOSE ONLY - Shows real data theft techniques
 */
class DataExfiltrationActivity : AppCompatActivity() {

    private lateinit var statusTextView: TextView
    private lateinit var collectButton: Button
    private lateinit var exfiltrateButton: Button
    private lateinit var analysisButton: Button
    
    private lateinit var dataCollector: DataCollector
    private val activityScope = CoroutineScope(Dispatchers.Main + SupervisorJob())

    private val requiredPermissions = arrayOf(
        Manifest.permission.READ_CONTACTS,
        Manifest.permission.READ_SMS,
        Manifest.permission.READ_CALL_LOG,
        Manifest.permission.ACCESS_FINE_LOCATION,
        Manifest.permission.READ_EXTERNAL_STORAGE,
        Manifest.permission.READ_PHONE_STATE,
        Manifest.permission.CAMERA,
        Manifest.permission.RECORD_AUDIO
    )

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_data_exfiltration)

        initializeViews()
        dataCollector = DataCollector(this)
        
        showDataExfiltrationWarning()
        checkPermissions()
    }

    private fun initializeViews() {
        statusTextView = findViewById(R.id.tv_exfiltration_status)
        collectButton = findViewById(R.id.btn_collect_data)
        exfiltrateButton = findViewById(R.id.btn_exfiltrate_data)
        analysisButton = findViewById(R.id.btn_analyze_data)

        collectButton.setOnClickListener { startDataCollection() }
        exfiltrateButton.setOnClickListener { simulateDataExfiltration() }
        analysisButton.setOnClickListener { showDataAnalysis() }
    }

    private fun showDataExfiltrationWarning() {
        AlertDialog.Builder(this)
            .setTitle("‚ö†Ô∏è Data Exfiltration Demo")
            .setMessage("""
                This demonstrates how malware steals personal data:
                
                üéØ DATA TARGETS:
                ‚Ä¢ Personal contacts and relationships
                ‚Ä¢ Private messages and communications
                ‚Ä¢ Location history and movement patterns
                ‚Ä¢ Photos and personal media
                ‚Ä¢ Financial and banking information
                ‚Ä¢ Authentication credentials
                
                üì° EXFILTRATION METHODS:
                ‚Ä¢ Background data transmission
                ‚Ä¢ Encrypted communication channels
                ‚Ä¢ Steganographic hiding techniques
                ‚Ä¢ Periodic batch uploads
                
                ‚ö†Ô∏è This is for educational purposes only!
            """.trimIndent())
            .setPositiveButton("Understood", null)
            .show()
    }

    private fun checkPermissions() {
        val grantedPermissions = mutableListOf<String>()
        val deniedPermissions = mutableListOf<String>()

        for (permission in requiredPermissions) {
            if (ContextCompat.checkSelfPermission(this, permission) == PackageManager.PERMISSION_GRANTED) {
                grantedPermissions.add(permission)
            } else {
                deniedPermissions.add(permission)
            }
        }

        updateStatus("""
            === DATA ACCESS PERMISSIONS ANALYSIS ===
            
            ‚úÖ GRANTED PERMISSIONS (${grantedPermissions.size}):
            ${grantedPermissions.joinToString("\n") { "‚Ä¢ ${it.substringAfterLast('.')}" }}
            
            ‚ùå MISSING PERMISSIONS (${deniedPermissions.size}):
            ${deniedPermissions.joinToString("\n") { "‚Ä¢ ${it.substringAfterLast('.')}" }}
            
            üö® RISK ASSESSMENT:
            ${if (grantedPermissions.size > 4) "HIGH RISK - Significant data access available" 
              else if (grantedPermissions.size > 2) "MEDIUM RISK - Some sensitive data accessible"
              else "LOW RISK - Limited data access"}
            
            üí° Ready to demonstrate data collection techniques
        """.trimIndent())

        // Enable buttons based on permissions
        collectButton.isEnabled = grantedPermissions.isNotEmpty()
        
        if (deniedPermissions.isNotEmpty()) {
            showPermissionRequestDialog(deniedPermissions)
        }
    }

    private fun showPermissionRequestDialog(deniedPermissions: List<String>) {
        AlertDialog.Builder(this)
            .setTitle("Additional Permissions Required")
            .setMessage("To demonstrate comprehensive data exfiltration, this app needs access to sensitive data. This is exactly what malware requests to steal your information.")
            .setPositiveButton("Grant Permissions") { _, _ ->
                ActivityCompat.requestPermissions(
                    this, 
                    deniedPermissions.toTypedArray(), 
                    PERMISSION_REQUEST_CODE
                )
            }
            .setNegativeButton("Continue with Limited Access", null)
            .show()
    }

    private fun startDataCollection() {
        updateStatus("üîÑ INITIATING DATA COLLECTION ATTACK...\n\n")
        
        activityScope.launch {
            try {
                // Phase 1: Reconnaissance
                updateStatus("Phase 1: Device reconnaissance and profiling...")
                delay(1000)
                
                val deviceProfile = dataCollector.collectDeviceProfile()
                logCollectedData("device_profile.json", deviceProfile)
                
                // Phase 2: Contact harvesting
                updateStatus("Phase 2: Harvesting contact information...")
                delay(1000)
                
                val contacts = dataCollector.collectContacts()
                logCollectedData("contacts.json", contacts)
                updateStatus("üìû Collected ${contacts.split('\n').size - 1} contacts")
                
                // Phase 3: Communication interception
                updateStatus("Phase 3: Intercepting communications...")
                delay(1000)
                
                val messages = dataCollector.collectSMSMessages()
                logCollectedData("messages.json", messages)
                updateStatus("üí¨ Intercepted ${messages.split('\n').size - 1} messages")
                
                // Phase 4: Location tracking
                updateStatus("Phase 4: Tracking location and movement patterns...")
                delay(1000)
                
                val locationData = dataCollector.collectLocationData()
                logCollectedData("location.json", locationData)
                
                // Phase 5: Media harvesting
                updateStatus("Phase 5: Harvesting media and files...")
                delay(1000)
                
                val mediaFiles = dataCollector.collectMediaFiles()
                logCollectedData("media.json", mediaFiles)
                
                // Phase 6: App usage analysis
                updateStatus("Phase 6: Analyzing app usage patterns...")
                delay(1000)
                
                val appUsage = dataCollector.collectAppUsageStats()
                logCollectedData("app_usage.json", appUsage)
                
                updateStatus("‚úÖ DATA COLLECTION COMPLETED!")
                updateStatus("üìä Comprehensive user profile created")
                updateStatus("üéØ ${calculateDataValue()} data points collected")
                updateStatus("\nüö® CRITICAL: All personal information compromised!")
                
                exfiltrateButton.isEnabled = true
                analysisButton.isEnabled = true
                
                showDataCollectionSuccess()

            } catch (e: Exception) {
                updateStatus("‚ùå Collection error: ${e.message}")
            }
        }
    }

    private fun simulateDataExfiltration() {
        updateStatus("üåê INITIATING DATA EXFILTRATION...\n\n")
        
        activityScope.launch {
            try {
                updateStatus("üì° Establishing encrypted channel to C2 server...")
                delay(1500)
                
                updateStatus("üîê Encrypting sensitive data packages...")
                delay(1000)
                
                updateStatus("üì§ Uploading batch 1/3: Contact database...")
                delay(2000)
                
                updateStatus("üì§ Uploading batch 2/3: Message archive...")
                delay(2000)
                
                updateStatus("üì§ Uploading batch 3/3: Location history...")
                delay(2000)
                
                updateStatus("üóëÔ∏è Clearing local traces...")
                delay(1000)
                
                updateStatus("‚úÖ EXFILTRATION COMPLETED!")
                updateStatus("üí∞ Data sold on dark web: $2,847")
                updateStatus("üé≠ Identity theft risk: CRITICAL")
                updateStatus("üìä Banking fraud potential: HIGH")
                updateStatus("\nüö® USER PRIVACY COMPLETELY COMPROMISED!")
                
                showExfiltrationSuccess()

            } catch (e: Exception) {
                updateStatus("‚ùå Exfiltration error: ${e.message}")
            }
        }
    }

    private fun showDataAnalysis() {
        activityScope.launch {
            val analysis = dataCollector.generateDataAnalysisReport()
            
            AlertDialog.Builder(this@DataExfiltrationActivity)
                .setTitle("üìä Stolen Data Analysis")
                .setMessage(analysis)
                .setPositiveButton("Close", null)
                .show()
        }
    }

    private fun showDataCollectionSuccess() {
        AlertDialog.Builder(this)
            .setTitle("üéØ DATA COLLECTION SUCCESSFUL")
            .setMessage("""
                Complete user profile created!
                
                STOLEN INFORMATION INCLUDES:
                ‚Ä¢ Complete contact list with relationships
                ‚Ä¢ Private message history and patterns
                ‚Ä¢ Precise location tracking data
                ‚Ä¢ Personal photos and media files
                ‚Ä¢ App usage and behavior patterns
                ‚Ä¢ Device and account credentials
                
                This data can be used for:
                ‚Ä¢ Identity theft and fraud
                ‚Ä¢ Social engineering attacks
                ‚Ä¢ Blackmail and extortion
                ‚Ä¢ Targeted phishing campaigns
                ‚Ä¢ Financial account compromise
            """.trimIndent())
            .setPositiveButton("Understood", null)
            .show()
    }

    private fun showExfiltrationSuccess() {
        AlertDialog.Builder(this)
            .setTitle("üö® EXFILTRATION COMPLETED")
            .setMessage("""
                All personal data transmitted to attackers!
                
                CONSEQUENCES:
                ‚Ä¢ Complete privacy violation
                ‚Ä¢ Identity theft risk
                ‚Ä¢ Financial fraud exposure  
                ‚Ä¢ Social engineering vulnerability
                ‚Ä¢ Ongoing surveillance capability
                
                The user would be completely unaware
                that their entire digital life has been
                compromised and is being monitored.
            """.trimIndent())
            .setPositiveButton("Understood", null)
            .show()
    }

    private fun logCollectedData(filename: String, data: String) {
        try {
            val dataDir = filesDir.resolve(".stolen_data")
            if (!dataDir.exists()) {
                dataDir.mkdirs()
            }
            
            val file = dataDir.resolve(filename)
            file.writeText(data)
            
        } catch (e: Exception) {
            // Silently fail - typical malware behavior
        }
    }

    private fun calculateDataValue(): String {
        try {
            val dataDir = filesDir.resolve(".stolen_data")
            if (!dataDir.exists()) return "0"
            
            var totalSize = 0L
            var fileCount = 0
            
            dataDir.listFiles()?.forEach { file ->
                totalSize += file.length()
                fileCount++
            }
            
            return "$fileCount files (${totalSize / 1024}KB)"
            
        } catch (e: Exception) {
            return "Unknown"
        }
    }

    private fun updateStatus(message: String) {
        statusTextView.text = "${statusTextView.text}$message\n"
        statusTextView.post {
            val parent = statusTextView.parent as android.widget.ScrollView
            parent.fullScroll(android.widget.ScrollView.FOCUS_DOWN)
        }
    }

    override fun onRequestPermissionsResult(
        requestCode: Int, 
        permissions: Array<out String>, 
        grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        
        if (requestCode == PERMISSION_REQUEST_CODE) {
            val grantedCount = grantResults.count { it == PackageManager.PERMISSION_GRANTED }
            
            if (grantedCount > 0) {
                Toast.makeText(this, "Permissions granted - Data collection enabled", Toast.LENGTH_LONG).show()
                checkPermissions()
            } else {
                Toast.makeText(this, "Permissions denied - Limited data access", Toast.LENGTH_LONG).show()
            }
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        activityScope.cancel()
    }

    companion object {
        private const val PERMISSION_REQUEST_CODE = 2001
    }
}
